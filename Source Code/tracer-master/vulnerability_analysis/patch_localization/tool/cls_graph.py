#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
-----------------------------------------
@Created: 2021/02/14
------------------------------------------
@Modify: 2021/02/14
------------------------------------------
@Description:

写祝福语的时候，真就完全不知道你遇到啥困境，以及期待什么。。
"""
import os,sys,re

from vulnerability_analysis.utility import string_similarity_util

_PROJECT_NAME = 'VulnerabilityAnalysis'
_CURRENT_ABSPATH = os.path.abspath(__file__)
sys.path.insert(0, _CURRENT_ABSPATH[:_CURRENT_ABSPATH.find(_PROJECT_NAME) + len(_PROJECT_NAME) + 1])

from vulnerability_analysis.patch_localization.tool import  cls_node
from vulnerability_analysis.patch_localization.tool import  confirm_patch, evaluate
from vulnerability_analysis.utility.NVD import CVE_metadata_util
from vulnerability_analysis.utility import parse_github_commit_util, parse_other_git_format_util, github_util
from vulnerability_analysis.utility.crawler import crawler_db as cdb
import re

import copy
import networkx as nx
import matplotlib
import matplotlib.font_manager
import matplotlib.pyplot as plt
# import FontSizeAll
# plt.rcParams["font.family"] = "Times New Roman"
# matplotlib.rcParams.update({'font.family' : 'TraditionalArabic'})

# matplotlib.rcParams['axes.linewidth'] = FontSizeAll.Line_WIDTH
matplotlib.font_manager.fontManager.addfont("/mydisk/fudan_se_cam/Hkf/Times New Roman.ttf")
plt.rcParams["font.family"] = "Times New Roman"
plt.rcParams['axes.unicode_minus'] = False

# plt.rcParams['font.family'] = 'serif'
# plt.rcParams['font.serif'] = ['Times New Roman'] + plt.rcParams['font.serif']

from networkx.drawing.nx_agraph import write_dot, graphviz_layout
# graphviz下载： https://blog.csdn.net/fadai1993/article/details/82491657
# 文档： https://www.osgeo.cn/networkx/install.html

import datetime
from backports.datetime_fromisoformat import MonkeyPatch
MonkeyPatch.patch_fromisoformat()

from vulnerability_analysis import config
from vulnerability_analysis.utility import re_util, parse_other_git_format_util
l1_split_str = config.L1_SPLITE_STR
l2_split_str = config.L2_SPLITE_STR

repo_similarity_threshold_value = 0.5 #

class Graph:
    """
    class Graph
    Attributes:
        root_node = None    # in fact, it's CVEID
        nodes = []          # all nodes object in  this graph
        edges_list = []     # edges in list, [ (parent_node, weight, child_node) ...] ,convenient for edges iteration
        edges_dict = []     # edges in dict, {parent_node:{child_node:weight}}  ,convenient for  graph traversal
    """

    def __init__(self, CVEID):
        # init
        self.root_node = None  # in fact, it's CVEID
        self.nodes = []  # all nodes object in  this graph
        self.node_id_list = []  # node_id_list, node_id index same with node index
        self.edges_list = []  # edges in list, [ (parent_node_id, weight, child_node_id) ...] ,convenient for edges iteration
        self.edges_dict = []  # edges in dict, {parent_node_id:{child_node_id:weight}}  ,convenient for  graph traversal

        self.root_node = cls_node.Node(node_content_type='cveid', node_content=CVEID)
        self.add_node(self.root_node)
        self.G = None           # 用于存储network的Graph

    def add_node(self, node: cls_node.Node):
        self.nodes.append( node )
        self.node_id_list.append( node.formatted_id )

    def add_edges(self, edge_list):
        for edge_ele in edge_list:
            parent_node, child_node, weight = edge_ele[0], edge_ele[1], edge_ele[2]
            if parent_node.formatted_id in self.node_id_list and child_node.formatted_id not in self.node_id_list: # 父节点在图中, 子节点不在图中
                self.add_node(child_node)
                self.edges_list.append( (parent_node.formatted_id, weight, child_node.formatted_id) )
            else:
                # 该节点对象，内存回收
                pass

    def add_edge(self, parent_node, child_node, weight=None, edge_description=None):
        # visualise_graph(self): 建图中，涉及edge元组信息下标
        if parent_node.formatted_id in self.node_id_list and child_node.formatted_id not in self.node_id_list: # 父节点在图中, 子节点不在图中
            self.add_node(child_node)
            self.edges_list.append( (parent_node.formatted_id, weight, edge_description, child_node.formatted_id) )
            return True
        elif parent_node.formatted_id in self.node_id_list and child_node.formatted_id in self.node_id_list:
            # if (parent_node.formatted_id, weight, child_node.formatted_id) not in self.edges_list: #边不在图中
            for edge_ele in self.edges_list:
                if parent_node.formatted_id in edge_ele and child_node.formatted_id in edge_ele : return False#边在图中
            self.edges_list.append( (parent_node.formatted_id, weight, edge_description, child_node.formatted_id) )
        else:
            # 该节点对象，内存回收
            pass
            return False

    def build_graph(self):
        # 建图, self.G = G  # 存储graph至该对象
        G = nx.DiGraph()
        for edge in self.edges_list:
            des = edge[-2]
            if des:
                G.add_edge(edge[0], edge[-1], desc=des)
            else:
                G.add_edge(edge[0], edge[-1])
        self.G = G  # 存储graph至该对象

    def visualise_graph(self, show_fig=False, save_fig=False, save_fig_path=None):
        # 建图
        G = nx.DiGraph()
        self.change_node_id(origin_id='N', new_id='NVD')
        self.change_node_id(origin_id='D', new_id='Debian')
        self.change_node_id(origin_id='R', new_id='Red Hat')
        for edge in self.edges_list:
            des = edge[-2]
            if des:
                if 'SG' == des:
                    existing_SG=True
                    # Github 加入节点信息
                    G.add_edge(self.root_node.formatted_id, 'GitHub')
                    G.add_edge('GitHub', edge[-1])
                    self.node_id_list.append('GitHub')
                    self.nodes.append(cls_node.Node(node_content_type='source', node_content='GitHub'))
                    # self.edges_list.remove(edge)
                else:
                    G.add_edge(edge[0], edge[-1], desc=des)
            else:
                G.add_edge(edge[0], edge[-1])
        # edges = [(edge[0], edge[-1]) for edge in self.edges_list]
        # G.add_edges_from(edges)

        # 上色
        nodes_color_list = []
        nodes_label_dict = {}
        nodes_list = list(G.nodes) # 加list， 是新建list对象， 不然nodes_list取值随着G.nodes进行变化
        for node in nodes_list:
            node_formatted_id = node
            node_index = self.node_id_list.index(node_formatted_id)
            node_obj = self.nodes[node_index]
            node_type = node_obj.type
            # 颜色
            if node_type=='issue_url':
                nodes_color_list.append('green')
                try:
                    nodes_label_dict[node_formatted_id] = '' + re.findall('[0-9]+',node_formatted_id)[-1][:6]
                    node_original_url = node_obj.original_content
                    label = node_original_url.split('/')[4].split('__fdse__')[0][:6] +'...'+ '\n#' +re.findall('[0-9]+',node_formatted_id)[-1][:6].split('__fdse__')[0]
                    nodes_label_dict[node_formatted_id] = label
                except:
                    print('ssss')
            elif node_type=='patch_url':
                nodes_color_list.append('red')
                if node_obj.category_in_type == 'git_commit':
                    nodes_label_dict[node_formatted_id] = '' + re_util.extract_commitid_in_commit_url( node_formatted_id ).__str__()

                    node_original_url = node_obj.original_content
                    if len(node_original_url.split('/'))>4:
                        label = node_original_url.split('/')[4].split('-')[0][:6] +'...' + '\n@' + re_util.extract_commitid_in_commit_url(node_formatted_id).__str__()[:4]
                    else:
                        label = '' + re_util.extract_commitid_in_commit_url( node_formatted_id ).__str__()
                    nodes_label_dict[node_formatted_id] = label
                elif node_obj.category_in_type == 'svn_commit':
                    nodes_label_dict[node_formatted_id] = '' + re_util.extract_commitid_in_svn_url( node_formatted_id ).__str__()
                else:
                    nodes_label_dict[node_formatted_id] = '' + node_formatted_id.split('/')[-1].split('_')[-1][:6]# 取前6位
            elif node_type=='root_node':
                nodes_color_list.append('grey')
                nodes_label_dict[node_formatted_id] = node_formatted_id
            elif node_type == 'source':
                nodes_color_list.append('grey')
                nodes_label_dict[node_formatted_id] = node_formatted_id
            else:
                nodes_color_list.append('blue')
                nodes_label_dict[node_formatted_id] = '' + node_formatted_id.split(l1_split_str)[0][-6:]  # 取前6位

                node_original_url = node_obj.original_content
                label = node_original_url.split('/')[2][:8] + '\n...' + node_original_url.split('__fdse__')[0].split('/')[-1].split('-')[-1][-8:]
                nodes_label_dict[node_formatted_id] = label
                # # 删除该节点
                # G.remove_node(node)

        # 布局
        # pos = nx.multipartite_layout(G)
        # pos = nx.drawing.nx_pydot.graphviz_layout(G, prog="dot")
        pos = nx.nx_agraph.graphviz_layout(G, prog="dot")# include: ‘dot’, ‘twopi’, ‘fdp’, ‘sfdp’, ‘circo’
        # 调整 D、R 节点距离，防止重叠
        if 'N' in pos: pos['N'] = (pos['N'][0]-400,pos['N'][1])
        if 'D' in pos: pos['D'] = (pos['D'][0]-100,pos['D'][1])
        if 'R' in pos: pos['R'] = (pos['R'][0]+400,pos['R'][1])
        if 'NVD' in pos: pos['NVD'] = (pos['NVD'][0] - 300, pos['NVD'][1])
        if 'Debian' in pos: pos['Debian'] = (pos['Debian'][0] + 150, pos['Debian'][1])
        if 'Red Hat' in pos: pos['Red Hat'] = (pos['Red Hat'][0] + 250, pos['Red Hat'][1])
        if 'GitHub' in pos: pos['GitHub'] = (pos['GitHub'][0] + 600, pos['GitHub'][1])

        # 美化排列
        pos = self.get_better_coordinate_for_graph(old_pos=pos, distance=600, switch_change_y=True,change_y=-10)
        nx.draw_networkx_labels(G, pos,font_size=6, font_weight='bold', alpha=1 , labels=nodes_label_dict, verticalalignment='center') # font_weight='bold',
        nx.draw_networkx_nodes(G, pos, node_size=400, node_color=nodes_color_list, alpha=0.3)
        nx.draw_networkx_edges(G, pos, node_size=400,arrows=True, arrowstyle="->", arrowsize=13, alpha=0.3, label=True)
        edge_labels = nx.get_edge_attributes(G, 'desc')
        nx.draw_networkx_edge_labels(G, pos, font_size=6, edge_labels=edge_labels)
        if show_fig: plt.show()
        if save_fig: plt.savefig(save_fig_path)
        plt.close() # https://blog.csdn.net/daixiangzi/article/details/82528927
        self.G = G # 存储graph至该对象

        # A = nx.drawing.nx_agraph.to_agraph(G)
        # A.draw('lang_predecessors.png', prog='dot')

    def change_node_id(self, origin_id,new_id):
        if origin_id in self.node_id_list:
            # 改节点
            index = self.node_id_list.index(origin_id)
            self.nodes[index].node_formatted_id = new_id
            self.node_id_list[index] = new_id

            # 改边
            for edge_index in range(len(self.edges_list)):
                edge = self.edges_list[edge_index]
                if origin_id == edge[0]:
                    edge = (new_id, edge[1], edge[2], edge[3])
                if origin_id == edge[-1]:
                    edge = (edge[0], edge[1], edge[2], new_id)
                self.edges_list[edge_index] = edge

    def get_better_coordinate_for_graph(self, old_pos, distance = 350,switch_change_y=False,  change_y=50):
        """ 美化节点坐标，使其不会互相重叠
        # step1: 找出所有的Y坐标
        # step2: 以Y位key，{ Y: sorted[x1,x2 ... ] }    { x1:node1, x2:node2, .... }
        # step3: 逐步又移x，使其不会重叠
        """
        new_pos = {}
        # step1: 找出所有的Y坐标
        # step2: 以Y位key，{ Y: sorted[x1,x2 ... ] }    {Y:{ x1:node1, x2:node2, .... }}
        y_dict = {}
        x_dict = {}
        for node in old_pos.keys():
            x = old_pos[node][0]
            y = old_pos[node][1]

            if str(y) not in y_dict:
                y_dict[str(y)] = [x]
                x_dict[str(y)] = {}
            else:
                y_dict[str(y)].append(x)
            if str(x) in x_dict[str(y)]:
                print('OMG!!')
            else:
                x_dict[str(y)][str(x)] = node

        # step3: 逐步又移x，使其不会重叠
        for y_ele in y_dict:
            y_dict[y_ele] = sorted( y_dict[y_ele] )

            last_x = y_dict[y_ele][0]
            node = x_dict[y_ele][str(last_x)]
            new_pos[node] = (float(last_x), float(y_ele))
            for x_ele in y_dict[y_ele][1:]:
                node = x_dict[y_ele][str(x_ele)]
                if float(x_ele) - float(last_x) < distance:
                    if len(y_dict[y_ele])>6 and  switch_change_y:
                        new_pos[node] = (float(last_x)+distance , float(y_ele) + change_y)
                        change_y *= -1
                    else:
                        new_pos[node] = (float(last_x)+distance , float(y_ele))
                    last_x += distance
                else:
                    if len(y_dict[y_ele])>6 and switch_change_y:
                        new_pos[node] = (float(x_ele), float(y_ele)+ change_y)
                        change_y *= -1
                    else:
                        new_pos[node] = (float(x_ele), float(y_ele))
                    last_x = x_ele

        return new_pos

    def visualise_graph_sample(self, show_fig=False, save_fig=False, save_fig_path=None):
        # 建图
        G = nx.DiGraph()
        # 修改NDR显示
        self.change_node_id(origin_id='N', new_id='NVD')
        self.change_node_id(origin_id='D', new_id='Debian')
        self.change_node_id(origin_id='R', new_id='Red Hat')
        # 修改issue显示
        for edge in self.edges_list:
            des = edge[-2]
            if des:
                # 去掉 ('55d682', None, 'EX', '814d1d')
                if edge == ('55d682', None, 'EX', '814d1d'):
                    continue
                # 更改 边显示
                if des == 'EX':
                    des = 'expand'
                G.add_edge(edge[0], edge[-1], desc=des)
            else:
                # NRD 加 contain
                if edge[0] in ['NVD', 'Debian','Red Hat' ]:
                    G.add_edge(edge[0], edge[-1], desc='contain')
                elif '140' in edge[0]:
                    if '163' in edge[-1]:
                        G.add_edge(edge[0], edge[-1],desc='reference')
                    else:
                        G.add_edge(edge[0], edge[-1])
                elif 'CVE-2017-11428' in edge[0]:
                    G.add_edge(edge[0], edge[-1])
                else:
                    G.add_edge(edge[0], edge[-1], desc='reference')

        G.add_edge('github.com__fdse__3', '482cdf', desc='reference')
        # https://github.com/russellhaering/gosaml2/issues/36
        G.add_edge('github.com__fdse__140', 'github.com__fdse__36')
        # G.add_edge('140', '36', desc='contain')
        self.node_id_list.append('github.com__fdse__36')
        self.nodes.append(cls_node.Node(node_content_type='url', node_content='https://github.com/russellhaering/gosaml2/issues/36'))

        # edges = [(edge[0], edge[-1]) for edge in self.edges_list]
        # G.add_edges_from(edges)
        pos = nx.nx_agraph.graphviz_layout(G, prog="dot")  # include: ‘dot’, ‘twopi’, ‘fdp’, ‘sfdp’, ‘circo’
        pos['GitHub'] = (pos['Debian'][0] + 100, pos['Debian'][1])

        G.add_edge('CVE-2017-11428', 'GitHub')
        G.add_edge('GitHub', '048a54',desc='contain')
        self.node_id_list.append('GitHub')
        self.nodes.append(cls_node.Node(node_content_type='source', node_content='GitHub'))
        G.remove_edge('CVE-2017-11428','048a54')
        # # ('048a54', 'd7ce60') ('048a54', 'a35f72'), ('048a54', '03af9e')
        # G.add_edge('048a54', 'd7ce60', desc='EX')
        # G.add_edge('048a54', 'a35f72', desc='EX')
        # G.add_edge('048a54', '03af9e', desc='EX')

        # 上色
        nodes_color_list = []
        nodes_label_dict = {}
        nodes_list = list(G.nodes) # 加list， 是新建list对象， 不然nodes_list取值随着G.nodes进行变化

        for node in nodes_list:
            node_formatted_id = node
            node_index = self.node_id_list.index(node_formatted_id)
            node_obj = self.nodes[node_index]
            node_type = node_obj.type
            # 颜色
            if node_type=='issue_url':
                nodes_color_list.append('green')
                try:
                    node_original_url = node_obj.original_content
                    label = node_original_url.split('/')[4] + '#' +re.findall('[0-9]+',node_formatted_id)[-1][:6]
                    nodes_label_dict[node_formatted_id] = label
                    # nodes_label_dict[node_formatted_id] = '' + re.findall('[0-9]+',node_formatted_id)[-1][:6]
                except:
                    print('ssss')
            elif node_type=='patch_url':
                nodes_color_list.append('red')
                if node_obj.category_in_type == 'git_commit':
                    node_original_url = node_obj.original_content
                    label = node_original_url.split('/')[4] + '\n@' + re_util.extract_commitid_in_commit_url( node_formatted_id ).__str__()
                    nodes_label_dict[node_formatted_id] = label
                    # nodes_label_dict[node_formatted_id] = '' + re_util.extract_commitid_in_commit_url( node_formatted_id ).__str__()
                elif node_obj.category_in_type == 'svn_commit':
                    nodes_label_dict[node_formatted_id] = '' + re_util.extract_commitid_in_svn_url( node_formatted_id ).__str__()
                else:
                    nodes_label_dict[node_formatted_id] = '' + node_formatted_id.split('/')[-1].split('_')[-1][:6]# 取前6位
            elif node_type=='root_node':
                nodes_color_list.append('grey')
                nodes_label_dict[node_formatted_id] = node_formatted_id
            elif node_type == 'source':
                nodes_color_list.append('grey')
                nodes_label_dict[node_formatted_id] = node_formatted_id
            else:
                # ('NVD', 'https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations'), (
                # 'NVD', 'https://www.kb.cert.org/vuls/id/475445')
                nodes_color_list.append('blue')
                node_original_url = node_obj.formatted_id
                label = node_original_url.split('/')[2] + '/...' + node_original_url.split('/')[-1].split('-')[-1]
                nodes_label_dict[node_formatted_id] = label
                # nodes_label_dict[node_formatted_id] = '' + node_formatted_id.split(l1_split_str)[0][-6:]  # 取前6位
                # # 删除该节点
                # G.remove_node(node)

        # 布局
        # pos = nx.multipartite_layout(G)
        # pos = nx.drawing.nx_pydot.graphviz_layout(G, prog="dot")

        # 调整 D、R 节点距离，防止重叠
        pos['github.com__fdse__3'] = (pos['github.com__fdse__3'][0] - 100, pos['github.com__fdse__3'][1])
        pos['482cdf'] = ( (pos['github.com__fdse__3'][0] + pos['github.com__fdse__140'][0])/2 +30 , pos['github.com__fdse__3'][1])

        pos['https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations'] = (pos['https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations'][0]+260,pos['https://duo.com/blog/duo-finds-saml-vulnerabilities-affecting-multiple-implementations'][1])
        pos['NVD'] = (pos['NVD'][0] - 160, pos['NVD'][1])
        if 'Debian' in pos: pos['Debian'] = (pos['Debian'][0]-100,pos['Debian'][1])
        if 'Red Hat' in pos: pos['Red Hat'] = (pos['Red Hat'][0]+100,pos['Red Hat'][1])

        G.remove_edge('github.com__fdse__163', 'github.com__fdse__141')
        # G.remove_node('github.com__fdse__141')
        # pos.pop('github.com__fdse__141')

        # Serif  , Times New Roman font_family='Times New Roman',
        # nx.draw_networkx_labels(G, pos, font_size=6, font_family='Serif', font_weight='bold', alpha=1 , labels=nodes_label_dict, verticalalignment='center') # font_weight='bold',
        nx.draw_networkx_labels(G, pos, font_size=8, font_family='Times New Roman', font_weight='bold', alpha=1, labels=nodes_label_dict, verticalalignment='center')  # font_weight='bold',
        edge_labels = nx.get_edge_attributes(G, 'desc')
        # nx.draw_networkx_edge_labels(G, pos, font_size=8, font_family='Times New Roman', edge_labels=edge_labels)

        nx.draw_networkx_nodes(G, pos, node_size=800, node_color=nodes_color_list, alpha=0.3)
        G.remove_edge('github.com__fdse__140', '55d682')
        G.remove_edge('github.com__fdse__140', '814d1d')
        G.remove_edge('github.com__fdse__140', 'github.com__fdse__36')
        nx.draw_networkx_edges(G, pos, node_size=800,width=0.8, arrows=True, arrowstyle="->", arrowsize=13, alpha=0.8, label=True)
        G.clear_edges()
        G.add_edge('github.com__fdse__140', '55d682')
        G.add_edge('github.com__fdse__140', '814d1d')
        G.add_edge('github.com__fdse__140', 'github.com__fdse__36')

        nx.draw_networkx_edges(G, pos, node_size=800, width=0.8,style='dotted' , arrows=True, arrowstyle="->", arrowsize=13, alpha=0.8,label=True)

        if show_fig: plt.show()
        if save_fig: plt.savefig(save_fig_path)
        plt.close() # https://blog.csdn.net/daixiangzi/article/details/82528927
        self.G = G # 存储graph至该对象

        # A = nx.drawing.nx_agraph.to_agraph(G)
        # A.draw('lang_predecessors.png', prog='dot')

    def get_nodes_by_attrs(self): # get nodes by nodes type or other attributes
        pass

    def get_patches_by_rules(self, rules=None):
        """根据rules，遍历graph，获取patches"""
        # rules = { 'src':['all'], 'searched_entities':['all'] , 'patch_type':['git_commit', 'svn'], 'patch_content':['only_code_change', 'patch_date ,'all'] } # rules为None时，即为全部patch
        selected_patch_nodes = []
        if rules: # todo
            candidate_patch_nodes = [node for node in self.nodes if node.type == 'patch_url']
            if rules['src']:
                if rules['patch_type'] == ['all']:
                    pass
                else:
                    for node_ele in candidate_patch_nodes:
                        node_ele_flag = True # 用于判定是否符合筛选条件
                        # todo, 'https://github.com/apache/thrift/pull/1606/files/7a5e210baa8783d46e5b183e036680d4b317b2a0'
                        if '/files/' in node_ele.formatted_url: continue # 先暂时这样处理

                        if node_ele.type == 'patch_url' and node_ele.category_in_type in rules['patch_type']:
                            if  rules['patch_content'] == ['all']:
                                selected_patch_nodes.append(node_ele)
                            else:# 'patch_date'
                                CVEID = self.root_node.formatted_id
                                CVE_item_content = CVE_metadata_util.main_no_present(CVEID)
                                if node_ele_flag and 'cutoff' in rules['patch_content'].__str__():
                                    cutoff_num = 4 # 获取cutoff 数值
                                    for ele in rules['patch_content']:
                                        if 'cutoff' in ele:
                                            cutoff_num = int(ele.split('=')[-1])
                                    node_id = node_ele.formatted_id
                                    node_paths_to_CVE = nx.algorithms.simple_paths.all_simple_paths(self.G, self.root_node.formatted_id,node_id, cutoff=cutoff_num)
                                    existing_path_flag = False
                                    for ele in node_paths_to_CVE:
                                        existing_path_flag = True # 说明存在:
                                        break
                                    if not existing_path_flag:
                                        node_ele_flag = False
                                if node_ele_flag and 'valid_patch_url' in rules['patch_content']:
                                    commit_date = None
                                    if node_ele.category_in_type == 'git_commit':
                                        # 是github commit
                                        if 'github' in node_ele.formatted_url:
                                            # node_ele.formatted_url
                                            res = github_util.is_valid_github_commit_url( url= node_ele.formatted_url)
                                            if not res: # 说明无效
                                                node_ele_flag = False
                                        else: # 其他类型的git commit
                                            # 通过request 判断
                                            ref_url = node_ele.formatted_url
                                            reponse_entity_from_DB = cdb.get(table='cve_ref', url=ref_url,crawler_method=cdb.S)  # option2， 基于crawler DB
                                            if reponse_entity_from_DB.status_code != 200: # 说明无效
                                                print('!= 200',1 ,ref_url)
                                                reponse_entity_from_DB = cdb.get(table='cve_ref', url=ref_url,crawler_method=cdb.S , force_update=True)  # option2， 基于crawler DB
                                                print(reponse_entity_from_DB.status_code, 2, ref_url)
                                            if reponse_entity_from_DB.status_code != 200: # 说明无效
                                                node_ele_flag = False
                                    else: # 非git commit
                                        # 通过request 判断
                                        ref_url = node_ele.formatted_url
                                        reponse_entity_from_DB = cdb.get(table='cve_ref', url=ref_url,crawler_method=cdb.S)  # option2， 基于crawler DB
                                        if reponse_entity_from_DB.status_code != 200:  # 说明无效
                                            reponse_entity_from_DB = cdb.get(table='cve_ref', url=ref_url,crawler_method=cdb.S,force_update=True)  # option2， 基于crawler DB
                                        if reponse_entity_from_DB.status_code != 200:  # 说明无效
                                            node_ele_flag = False
                                if node_ele_flag and 'patch_date' in rules['patch_content']:
                                    commit_date = None
                                    # 目前仅支持 github commit， 以及可准化为github commit的other git commit
                                    if node_ele.category_in_type == 'git_commit':
                                        # 是github commit
                                        if 'github' in node_ele.formatted_url:
                                            commit_metadata = parse_github_commit_util.get_commit_diff(url=node_ele.formatted_url)
                                            if commit_metadata and 'date' in commit_metadata.keys():
                                                commit_date = commit_metadata["date"]
                                        else: # 其他类型的git commit
                                            commit_metadata = parse_other_git_format_util.parse_other_git_format(url=node_ele.formatted_url)
                                            if commit_metadata and "date" in commit_metadata:
                                                commit_date = commit_metadata["date"]
                                        # 基于CVE发布时间，进行时间对比
                                        CVE_PublishedDate = CVE_item_content['PublishedData'] if CVE_item_content else None #'2018-06-04T19:29Z'
                                        if CVE_PublishedDate and commit_date:
                                            date_span = datetime.datetime.fromisoformat(CVE_PublishedDate.strip('Z')) - datetime.datetime.fromisoformat(commit_date.strip('Z'))
                                            # print( date_span.days )
                                            if abs(date_span.days) > 365*2:
                                                # 时差大于1年时，则不符和该rule； 后续不会放入selected_patch_nodes
                                                node_ele_flag = False
                                        else: # 没有该信息时，则不进行筛选
                                            pass
                                if node_ele_flag and 'only_target_CPEs' in rules['patch_content']:
                                    # 目前仅针对github commit，其他形式的patch，还没有做（todo）
                                    if 'gist' in node_ele.formatted_url: node_ele_flag = False # 有时候，graph中会误识别，来不及重跑，这里过滤一下
                                    if 'github.' in node_ele.formatted_url and 'commit' in node_ele.formatted_url: # 针对 github commit
                                        # https://github.com/apache/tomcat80/commit/2c9d8433bd3247a2856d4b255
                                        github_commit = node_ele.formatted_url
                                        VP_CPEs = CVE_item_content['AffectedVendorProductCPE'] if CVE_item_content else []
                                        VP_CPEs = [ele.replace('__fdse__', ':') for ele in VP_CPEs] if VP_CPEs else []
                                        res_repo = github_commit.split('github.com/')[-1].split('/')[1]
                                        # 计算最大相似度
                                        similarity_score_repo_max = 0
                                        for VP in VP_CPEs:
                                            # similarity_score_repo = string_similarity_util.AVG_similary_from_all(res_repo.lower(),VP.lower().split(':')[1])
                                            similarity_score_repo = string_similarity_util.CHAR_Levenshtein_distance(res_repo.lower(), VP.lower().split(':')[1])
                                            if similarity_score_repo_max < similarity_score_repo: similarity_score_repo_max = similarity_score_repo
                                        # 小于阈值时，则不符和该rule； 后续不会放入selected_patch_nodes
                                        if similarity_score_repo_max < repo_similarity_threshold_value: node_ele_flag = False
                                    elif 'git' in node_ele.formatted_url and re_util.extract_commitid_in_commit_url(node_ele.formatted_url): #针对 other git commit
                                        parsed_result = parse_other_git_format_util.parse_other_git_format(node_ele.formatted_url)
                                        # 当可转换为github commit时,进行甄别； 方法同上 github commit
                                        if parsed_result and 'patch_type' in parsed_result.keys() and parsed_result['patch_type'] == 'github commit':
                                            github_commit = parsed_result['html_url']
                                            VP_CPEs = CVE_item_content['AffectedVendorProductCPE'] if CVE_item_content else []
                                            VP_CPEs = [ele.replace('__fdse__', ':') for ele in VP_CPEs] if VP_CPEs else []
                                            res_repo = github_commit.split('github.com/')[-1].split('/')[1]
                                            res_owner = github_commit.split('github.com/')[-1].split('/')[0]
                                            # 计算最大相似度
                                            similarity_score_repo_max = 0
                                            for VP in VP_CPEs:
                                                # similarity_score_repo = string_similarity_util.AVG_similary_from_all(res_repo.lower(), VP.lower().split(':')[1])
                                                # option2 实际是owner + repo共同相似度的结果。
                                                similarity_score_owner = string_similarity_util.compare_matched_words(res_owner + '/' + res_repo.lower(), VP.lower())
                                                similarity_score_repo = string_similarity_util.compare_matched_words(res_owner + '/' + res_repo.lower(), VP.lower())
                                                if similarity_score_repo_max < similarity_score_repo: similarity_score_repo_max = similarity_score_repo
                                            # 小于阈值时，则不符和该rule； 后续不会放入selected_patch_nodes
                                            if similarity_score_repo_max < repo_similarity_threshold_value: node_ele_flag = False
                                if node_ele_flag and 'only_code_change' in rules['patch_content']:
                                    if node_ele.category_in_type == 'git_commit':
                                        res_not_doc_and_test = confirm_patch.filter_security_test_and_doc_commits(patch_list=[node_ele.formatted_url])
                                        # res_not_doc = confirm_patch.filter_security_doc_commits( patch_list=[node_ele.formatted_url] )
                                        # res_not_test = confirm_patch.filter_security_test_commits( patch_list=[node_ele.formatted_url] )
                                        if res_not_doc_and_test:
                                            selected_patch_nodes.append(node_ele)
                                        else:
                                            node_ele_flag = False
                                    elif node_ele.category_in_type == 'svn': #
                                        selected_patch_nodes.append(node_ele)
                                if node_ele_flag: # 以上条件都满足时,
                                    selected_patch_nodes.append(node_ele)
        else:
            # rules为None时，即为图中全部patch
            selected_patch_nodes = [ node for node in self.nodes if node.type=='patch_url']
        return selected_patch_nodes

    def compute_the_priority_of_nodes(self, nodes, rules='DP',CN_cutoff=4): # rules默认为Degree*connectivity
        # print('compute_the_priority_of_nodes:' , self)
        # print('len node_id_list: ', len(nodes), 'len edges_list: ', len( self.edges_list ))
        from networkx.algorithms import approximation as approx
        node_id_list = [ node.formatted_id for node in nodes ]
        node_priority_info = {}
        node_degree_info = self.G.degree()
        node_priority_list = []
        for node in nodes:
            node_id = node.formatted_id
            if rules=='CN':
                # 将所有路径，权重和相加；权重即为距离的倒数
                # node_paths_to_CVE = nx.algorithms.simple_paths.all_simple_paths(self.G, self.root_node.formatted_id,node_id)
                node_paths_to_CVE = nx.algorithms.simple_paths.all_simple_paths(self.G, self.root_node.formatted_id,node_id, cutoff=CN_cutoff)
                # node_paths_to_CVE = nx.algorithms.simple_paths.all_simple_edge_paths(self.G, self.root_node.formatted_id,node_id, cutoff=5)
                # option1, 仅删N
                node_priority_value_list = [ 1/pow(2,(len(path)-3)) if 'N' in path else 1/pow(2,(len(path)-2)) for path in node_paths_to_CVE ]              # option1, 仅删N ['CVE-2013-6450', 'N', 'httpxxx'] 为1， 所以，len(path)-3)
                # option2, 删NRD
                # node_priority_value_list = [1 / pow(2, (len(path) - 3)) if len(path)>2 else 1 / pow(2, (len(path) - 2)) for path in node_paths_to_CVE]      # option2, 删NRD ['CVE-2013-6450', 'N', 'httpxxx'] 为1， 所以，len(path)-3)
                # node_priority_value_list = [1 / (len(path) - 3) if 'N' in path else 1 / (len(path) - 2) for path in node_paths_to_CVE]
                node_priority = sum( node_priority_value_list )
                # node_priority = 0
                # for path in node_paths_to_CVE:
                #     if 'N' in path:
                #         node_distance_to_CVE = len(path) -1 -1 # 因为返回路径上的节点，所以，-1 以算距离深度; 又由于其是NVD直接节点 再-1
                #     else:
                #         node_distance_to_CVE = len(path) - 1
                #     node_priority += 1 / node_distance_to_CVE
                node_priority_info[node] = node_priority
            elif rules=='DG&C':
                node_degree = node_degree_info[node_id]
                node_conectivity_to_CVE = approx.local_node_connectivity(self.G, self.root_node.formatted_id, node_id)
                node_priority_info[node] = node_degree * node_conectivity_to_CVE
            elif rules=='PC': # path count
                node_paths_to_CVE = nx.algorithms.simple_paths.all_simple_paths(self.G, self.root_node.formatted_id,node_id, cutoff=CN_cutoff)
                path_cnt = 0
                for path in node_paths_to_CVE:
                    path_cnt+=1
                node_priority_info[node] = path_cnt
            elif rules=='DG':
                node_degree = node_degree_info[node_id]
                node_priority_info[node] = node_degree
            elif rules == 'C':
                node_conectivity_to_CVE = approx.local_node_connectivity(self.G, self.root_node.formatted_id, node_id)
                node_priority_info[node] = node_conectivity_to_CVE
            elif rules == 'DP':
                # print( nx.algorithms.shortest_path(self.G, self.root_node.formatted_id, node_id) )
                # node_distance_to_CVE = len( nx.algorithms.shortest_path(self.G, self.root_node.formatted_id, node_id) ) -1 # 因为返回路径上的节点，所以，-1 以算距离深度
                # node_distance_to_CVE = node_distance_to_CVE if node_distance_to_CVE>2 else 1    # distance 《=2时， 即SG or NVD，直接算为1
                nodes_to_CVE = nx.algorithms.shortest_path(self.G, self.root_node.formatted_id, node_id)
                node_distance_to_CVE = len(nodes_to_CVE) - 2 if 'N' in nodes_to_CVE else len(nodes_to_CVE) - 1        # option1,  仅删N,  'N' 最直接，不算为url层数
                # node_distance_to_CVE = len(nodes_to_CVE) -2 if len(nodes_to_CVE)>2 else len(nodes_to_CVE) -1            # option2,  全删NRD， nodes_to_CVE ==2时， 即SG, depth即-1; 其他情况，减去 N/R/D, -2
                node_priority_info[node] = (1/node_distance_to_CVE)                             # 取距离的倒数，以便排名；
            elif rules=='DG&DP':
                node_degree = node_degree_info[node_id]
                node_distance_to_CVE = len(nx.algorithms.shortest_path(self.G, self.root_node.formatted_id,node_id)) - 1  # 因为返回路径上的节点，所以，-1 以算距离深度
                node_distance_to_CVE = node_distance_to_CVE if node_distance_to_CVE > 2 else 1  # distance 《=2时， 即SG or NVD，直接算为1
                node_priority_info[node] = (node_degree / node_distance_to_CVE)                           # 取距离的倒数，以便排名；
            node_priority_list.append( node_priority_info[node] )
        return node_priority_info, node_priority_list

    def get_children_nodes_with_EX(self, node):
        selected_nodes = []
        node_id = node.formatted_id
        for edge_ele in self.edges_list:
            if node_id == edge_ele[0] and 'EX' in edge_ele:
                child_node_id = edge_ele[3]
                child_node_id_index = self.node_id_list.index( child_node_id )
                child_node = self.nodes[child_node_id_index]
                selected_nodes.append(child_node)
        return selected_nodes

    def get_direct_nodes_with_EX(self, node, days_span=30,valid_expansion_message=False):
        selected_nodes = []
        node_id = node.formatted_id
        CVEID = self.root_node.formatted_id
        for edge_ele in self.edges_list:
            if node_id in edge_ele and 'EX' in edge_ele:
                if node_id == edge_ele[3]: # child
                    parent_node_id = edge_ele[0]
                    parent_node_id_index = self.node_id_list.index(parent_node_id)
                    parent_node = self.nodes[parent_node_id_index]
                    selected_nodes.append(parent_node)
                elif node_id == edge_ele[0]: # parent
                    child_node_id = edge_ele[3]
                    child_node_id_index = self.node_id_list.index(child_node_id)
                    child_node = self.nodes[child_node_id_index]
                    selected_nodes.append(child_node)
        # 增加： 对于extension时，days的限制！
        if len(selected_nodes)>0: # 对于无ex的节点，也就不考虑了；ex的都是githhub commit
            selected_nodes_within_span = []
            selected_nodes_with_valid_meesage = []
            formatted_url = node.formatted_url
            commit_content = parse_github_commit_util.get_commit_metadata(url=formatted_url)  # 无内容的话，也就无 ex了
            if commit_content:
                original_node_date = commit_content['commit']['committer']['date']
                original_node_message = commit_content['commit']['message']
                for candi_ele in selected_nodes:
                    candi_ele_formatted_url = candi_ele.formatted_url
                    commit_content = parse_github_commit_util.get_commit_metadata(url=candi_ele_formatted_url)  # 无内容的话，也就无 ex了
                    if not commit_content:
                        # print(node.formatted_url, candi_ele_formatted_url)
                        selected_nodes_within_span.append(candi_ele)
                        continue
                    # 用于评判span
                    candi_ele_date = commit_content['commit']['committer']['date']
                    date_span = datetime.datetime.fromisoformat(
                        original_node_date.strip('Z')) - datetime.datetime.fromisoformat(candi_ele_date.strip('Z'))
                    # print( date_span.days,original_node_date,candi_ele_date)
                    # 0 2018-02-27T12:43:42Z 2018-02-27T10:27:45Z
                    # -1 2018-02-27T10:27:45Z 2018-02-27T12:43:42Z
                    if date_span.days < 0: #
                        if abs(date_span.days +1) <= days_span:
                            selected_nodes_within_span.append(candi_ele)
                            # print( original_node_date, candi_ele_date )
                    else:
                        if abs(date_span.days) <= days_span:
                            selected_nodes_within_span.append(candi_ele)
                            # print(original_node_date, candi_ele_date)

                    # 2018-08-01T16:10:14Z 2018-07-31T18:26:16Z

                    # 用于评判 message
                    candi_message = commit_content['commit']['message']
                    if CVEID in candi_message:
                        selected_nodes_with_valid_meesage.append(candi_ele)
                    else:
                        flag_true_expansion = False
                        # 当candi_message或message过短时， pass
                        # 不超过3个单词时，认为过短
                        message = original_node_message
                        if len(message.split(' ')) <2 or len(candi_message.split(' ')) <2: continue
                        # 当candi_message或message长度差距过大时， pass
                        # 当candi_message或message是典型无意义message时。
                        if candi_message == message or candi_message in message or message in candi_message:
                            selected_nodes_with_valid_meesage.append(candi_ele)

            if (days_span or days_span == 0) and valid_expansion_message:
                selected_nodes = list( set(selected_nodes_within_span).intersection(selected_nodes_with_valid_meesage ) )
            elif (days_span or days_span == 0) and not valid_expansion_message:
                selected_nodes = selected_nodes_within_span
        return selected_nodes

    def get_direct_and_indirect_nodes_with_EX(self, node):
        selected_nodes = []
        selected_nodes_id = []
        sub_selected_nodes = self.get_direct_nodes_with_EX(node)
        selected_nodes += sub_selected_nodes
        selected_nodes_id = [ ele_node.formatted_id for ele_node in sub_selected_nodes ] # 获取第一层 related nodes
        for selected_node in sub_selected_nodes:
            candiate_nodes = self.get_direct_nodes_with_EX(selected_node) # 获取第二层 related nodes
            for candiate_node in candiate_nodes:
                if candiate_node.formatted_id not in selected_nodes_id: # 不在候选中
                    selected_nodes.append( candiate_node )
        return selected_nodes

    def get_patch_nodes_with_less_depth(self, base_line_nodes, all_candidate_nodes, equal=False):
        """ 《= 输入node层数的其他patch node """
        node_priority_info, node_priority_list = self.compute_the_priority_of_nodes(
            nodes=all_candidate_nodes, rules='DP')
        # 获得priority_list
        if node_priority_list:
            # get the max score of base_line_nodes'
            max_base_line_nodes = 0
            for node in base_line_nodes:
                if node_priority_info[node] > max_base_line_nodes:
                    max_base_line_nodes = node_priority_info[node]
            if equal:
                candidate_patch_nodes = [node for node in node_priority_info if node_priority_info[node] >= max_base_line_nodes]
            else:
                candidate_patch_nodes = [node for node in node_priority_info if node_priority_info[node] > max_base_line_nodes]
            return candidate_patch_nodes
        else:
            return []

    def get_patch_nodes_with_same_parent_node(self, base_line_node, candidate_patch_nodes):
        """ 《get_patch_nodes_with_same_parent_node """
        candidate_patch_nodes_ids = [ node.formatted_id for node in candidate_patch_nodes ]

        returned_nodes = []
        # get all parent nodes
        parent_nodes = []
        node_id = base_line_node.formatted_id
        for edge_ele in self.edges_list:
                if node_id == edge_ele[3]: # child
                    parent_node_id = edge_ele[0]
                    parent_node_id_index = self.node_id_list.index(parent_node_id)
                    parent_node = self.nodes[parent_node_id_index]
                    parent_nodes.append(parent_node)
        # get all child patch nodes
        for parent_node in parent_nodes:
            node_id = parent_node.formatted_id
            for edge_ele in self.edges_list:
                if node_id == edge_ele[0]:  # child
                    child_node_id = edge_ele[3]
                    if child_node_id in candidate_patch_nodes_ids: # 符合起初的筛选条件
                        child_node_id_index = self.node_id_list.index(child_node_id)
                        child_node = self.nodes[child_node_id_index]
                        returned_nodes.append(child_node)
        return returned_nodes

    def get_patch_nodes_with_same_parent_nodes(self, base_line_nodes, all_candidate_nodes):
        """ 《get_patch_nodes_with_same_parent_node """
        returned_nodes = []
        for base_line_node in base_line_nodes:
            res = self.get_patch_nodes_with_same_parent_node( base_line_node,all_candidate_nodes )
            returned_nodes.extend( res )
        return returned_nodes

    def get_all_in_edges_of_a_node(self, node):
        in_edges = []
        node_id = node.formatted_id
        for edge_ele in self.edges_list:
            if node_id == edge_ele[-1]:
                in_edges.append( edge_ele )
        return in_edges

    def filter_out_only_EX_patch_nodes(self, nodes):
        """ 返回的结果为过滤only ex 后的list """
        result_nodes = []
        for node in nodes:
            # 获取所有的入边
            in_edges = self.get_all_in_edges_of_a_node(node)
            for edge in in_edges:
                # 如果 'EX' 未在其中，则命中
                if 'EX' not in edge:
                    result_nodes.append(node)
                    break
        return result_nodes
    def generate_new_url_graph_without_EX(self):
        rules = {'without': ['EX']}
        self.url_graph_without_EX = copy.deepcopy(self)
        # self.url_graph_without_EX.visualise_graph(show_fig=True)
        if 'EX' in rules['without']:
            # 删除所有 EX的边
            for edge_item_index in range(len(self.url_graph_without_EX.edges_list)).__reversed__():
                edge_item = self.url_graph_without_EX.edges_list[edge_item_index]
                if 'EX' in edge_item:
                    self.url_graph_without_EX.edges_list.remove( edge_item )
            edges_str = self.url_graph_without_EX.edges_list.__str__()
            # 判断所有节点，是否在某个边中，不再的话，即删除！
            for index in range(len(self.url_graph_without_EX.node_id_list)).__reversed__() :
                node_id = self.url_graph_without_EX.node_id_list[index]
                if node_id in edges_str:
                    pass
                else:
                    self.url_graph_without_EX.nodes.pop(index)
                    self.url_graph_without_EX.node_id_list.pop(index)
        self.url_graph_without_EX.build_graph() # 构建新的self.G
        # self.url_graph_without_EX.visualise_graph()  # 构建新的self.G
        # url_graph_without_EX = copy.deepcopy(self.url_graph_without_EX)
        return self.url_graph_without_EX

    def generate_new_url_graph_without_EX_2(self):
        rules = {'without': ['EX']}
        url_graph_without_EX = copy.deepcopy(self)
        url_graph_without_EX.edges_list = []
        url_graph_without_EX.nodes = []
        url_graph_without_EX.node_id_list = []
        if 'EX' in rules['without']:
            # 删除所有 EX的边
            for edge_item_index in range(len(self.edges_list)).__reversed__():
                edge_item = self.edges_list[edge_item_index]
                if 'EX' in edge_item.__str__():
                    pass
                else:
                    url_graph_without_EX.edges_list.append(edge_item)
            edges_str = url_graph_without_EX.edges_list.__str__()
            # 判断所有节点，是否在某个边中，不再的话，即删除！
            for index in range(len(self.node_id_list)).__reversed__() :
                node_id = self.node_id_list[index]
                if node_id in edges_str:
                    node = self.nodes[index]
                    url_graph_without_EX.node_id_list.append(node_id )
                    url_graph_without_EX.nodes.append(node)
                else:
                    pass
        return url_graph_without_EX

    def generate_new_url_graph_with_rules(self, rules=False, patches_satisfying_rules=False, pingbi_ganrao=False):
        self.url_graph_with_rules = copy.deepcopy(self)
        self.url_graph_with_rules.build_graph()  # 构建新的self.G
        if rules:
            patches_node_id = []
            CVE_patch_pathes = []
            for ele in patches_satisfying_rules:
                patches_node_id.append( ele.formatted_id )

                node_id = ele.formatted_id
                CN_cutoff = 4
                node_paths_to_CVE = nx.algorithms.simple_paths.all_simple_paths(self.G, self.root_node.formatted_id, node_id, cutoff=CN_cutoff)
                for path in node_paths_to_CVE:
                    CVE_patch_pathes.append( path  )
        # print(CVE_patch_pathes.__str__()  )

        # commit节点，非patch则删除
        # issue节点，与patch无关则删除
        if pingbi_ganrao:
            for index in range(len(self.url_graph_with_rules.node_id_list)).__reversed__():
                node_id = self.url_graph_with_rules.node_id_list[index]
                node = self.url_graph_with_rules.nodes[index]
                if node.type == 'patch_url':
                    # commit节点，非patch则删除
                    if node_id in patches_node_id:
                        pass
                    else:
                        self.url_graph_with_rules.nodes.pop(index)
                        self.url_graph_with_rules.node_id_list.pop(index)
                elif node.type == 'issue_url':
                    # issue节点，与patch无关则删除
                        if node_id in CVE_patch_pathes.__str__():
                            pass
                        else:
                            self.url_graph_with_rules.nodes.pop(index)
                            self.url_graph_with_rules.node_id_list.pop(index)
                # 判断所有边，是否节点都在，不再的话，即删除！
            for edge_item_index in range(len(self.url_graph_with_rules.edges_list)).__reversed__():
                edge_item = self.url_graph_with_rules.edges_list[edge_item_index]
                if not( edge_item[0] in self.url_graph_with_rules.node_id_list and edge_item[-1] in self.url_graph_with_rules.node_id_list):
                    self.url_graph_with_rules.edges_list.remove(edge_item)
        self.url_graph_with_rules.build_graph()  # 构建新的self.G

        # 仅保留符合rules的patch节点
        if True:
            for index in range(len(self.url_graph_with_rules.node_id_list)).__reversed__():
                node_id = self.url_graph_with_rules.node_id_list[index]
                node = self.url_graph_with_rules.nodes[index]
                if node.type == 'patch_url':
                    # commit节点，非patch则删除
                    if node_id in patches_node_id:
                        pass
                    else:
                        self.url_graph_with_rules.nodes.pop(index)
                        self.url_graph_with_rules.node_id_list.pop(index)

        # attach 节点的patch去掉
        # 无效EX节点，则删除
        if True:
            # 删除所有 attach的边
            for edge_item_index in range(len(self.url_graph_with_rules.edges_list)).__reversed__():
                edge_item = self.url_graph_with_rules.edges_list[edge_item_index]
                if 'attach' in edge_item.__str__():
                    self.url_graph_with_rules.edges_list.remove(edge_item)
                # 无效EX节点，则删除; 判定规则：一个被选中，另一个没有
                elif 'EX' in edge_item.__str__():
                    if (edge_item[0] in patches_node_id and edge_item[-1] not in patches_node_id) \
                        or (edge_item[-1] in patches_node_id and edge_item[0] not in patches_node_id):
                        self.url_graph_with_rules.edges_list.remove(edge_item)
            edges_str = self.url_graph_with_rules.edges_list.__str__()
            # 判断所有节点，是否在某个边中，不再的话，即删除！
            for index in range(len(self.url_graph_with_rules.node_id_list)).__reversed__():
                node_id = self.url_graph_with_rules.node_id_list[index]
                if node_id in edges_str:
                    pass
                else:
                    self.url_graph_with_rules.nodes.pop(index)
                    self.url_graph_with_rules.node_id_list.pop(index)

        # 深度>4的点，去掉

        # 判断所有节点，是否在某个边中，不再的话，即删除！
        for index in range(len(self.url_graph_with_rules.node_id_list)).__reversed__():
            node_id = self.url_graph_with_rules.node_id_list[index]
            if node_id in edges_str:
                pass
            else:
                self.url_graph_with_rules.nodes.pop(index)
                self.url_graph_with_rules.node_id_list.pop(index)
        # 判断所有边，是否节点都在，不再的话，即删除！
        for edge_item_index in range(len(self.url_graph_with_rules.edges_list)).__reversed__():
            edge_item = self.url_graph_with_rules.edges_list[edge_item_index]
            if not (edge_item[0] in self.url_graph_with_rules.node_id_list and edge_item[
                -1] in self.url_graph_with_rules.node_id_list):
                self.url_graph_with_rules.edges_list.remove(edge_item)

        # 美化
        self.url_graph_with_rules.build_graph()  # 构建新的self.G
        # self.url_graph_with_rules.visualise_graph(show_fig=True)
        return self.url_graph_with_rules

    def visualise_graph_better(self, show_fig=False, save_fig=False, save_fig_path=False):
        # 建图
        G = nx.DiGraph()
        # 修改NDR显示
        self.change_node_id(origin_id='N', new_id='NVD')
        self.change_node_id(origin_id='D', new_id='Debian')
        self.change_node_id(origin_id='R', new_id='Red Hat')
        existing_SG = False
        for edge in self.edges_list:
            des = edge[-2]
            if des:
                if 'SG' == des:
                    existing_SG=True
                    # Github 加入节点信息
                    G.add_edge(self.root_node.formatted_id, 'GitHub')
                    G.add_edge('GitHub', edge[-1])
                    self.node_id_list.append('GitHub')
                    self.nodes.append(cls_node.Node(node_content_type='source', node_content='GitHub'))
                else:
                    G.add_edge(edge[0], edge[-1], desc=des)
            else:
                G.add_edge(edge[0], edge[-1])

        # 上色
        nodes_color_list = []
        nodes_label_dict = {}
        nodes_list = list(G.nodes)  # 加list， 是新建list对象， 不然nodes_list取值随着G.nodes进行变化
        for node in nodes_list:
            node_formatted_id = node
            node_index = self.node_id_list.index(node_formatted_id)
            node_obj = self.nodes[node_index]
            node_type = node_obj.type
            # 颜色
            if node_type == 'issue_url':
                nodes_color_list.append('green')
                try:
                    node_original_url = node_obj.original_content
                    label = node_original_url.split('/')[4] + '#' + re.findall('[0-9]+', node_formatted_id)[-1][:6]
                    nodes_label_dict[node_formatted_id] = label
                    # nodes_label_dict[node_formatted_id] = '' + re.findall('[0-9]+',node_formatted_id)[-1][:6]
                except:
                    print('ssss')
            elif node_type == 'patch_url':
                nodes_color_list.append('red')
                if node_obj.category_in_type == 'git_commit':
                    node_original_url = node_obj.original_content
                    if len( node_original_url.split('/') ) <5:
                        label =  '@' + re_util.extract_commitid_in_commit_url(node_formatted_id).__str__()
                    else:
                        label = node_original_url.split('/')[4] + '\n@' + re_util.extract_commitid_in_commit_url(
                            node_formatted_id).__str__()
                    nodes_label_dict[node_formatted_id] = label
                    # nodes_label_dict[node_formatted_id] = '' + re_util.extract_commitid_in_commit_url( node_formatted_id ).__str__()
                elif node_obj.category_in_type == 'svn_commit':
                    nodes_label_dict[node_formatted_id] = '' + re_util.extract_commitid_in_svn_url(
                        node_formatted_id).__str__()
                else:
                    nodes_label_dict[node_formatted_id] = '' + node_formatted_id.split('/')[-1].split('_')[-1][
                                                               :6]  # 取前6位
            elif node_type == 'root_node':
                nodes_color_list.append('grey')
                nodes_label_dict[node_formatted_id] = node_formatted_id
            elif node_type == 'source':
                nodes_color_list.append('grey')
                nodes_label_dict[node_formatted_id] = node_formatted_id
            else:

                nodes_color_list.append('blue')
                node_original_url = node_obj.formatted_id
                label = node_original_url.split('/')[2] + '/' + '...' + node_original_url.split('/')[-1].split('-')[-1]
                label = node_original_url.split('/')[2].strip('.com') + '/' + '...' + node_original_url[-6:]
                label = label.strip('http').strip('www.')
                # label = node_original_url[:6] + '/' + '...' + node_original_url[-6:]
                n=10
                label_list = [label[i:i + n] for i in range(0, len(label), n)]
                label = '\n'.join(label_list)
                nodes_label_dict[node_formatted_id] = label

        pos = nx.nx_agraph.graphviz_layout(G, prog="dot")  # include: ‘dot’, ‘twopi’, ‘fdp’, ‘sfdp’, ‘circo’
        pos['NVD'] = (pos['NVD'][0] - 100, pos['NVD'][1])
        if 'Debian' in pos: pos['Debian'] = (pos['Debian'][0] - 100, pos['Debian'][1])
        if 'Red Hat' in pos: pos['Red Hat'] = (pos['Red Hat'][0] + 100, pos['Red Hat'][1])
        if 'GitHub' in pos: pos['Red Hat'] = (pos['Red Hat'][0] + 100, pos['Red Hat'][1])

        # Serif  , Times New Roman font_family='Times New Roman',
        # nx.draw_networkx_labels(G, pos, font_size=6, font_family='Serif', font_weight='bold', alpha=1 , labels=nodes_label_dict, verticalalignment='center') # font_weight='bold',
        nx.draw_networkx_labels(G, pos, font_size=8, font_family='Times New Roman', font_weight='bold', alpha=1,
                                labels=nodes_label_dict, verticalalignment='center')  # font_weight='bold',
        edge_labels = nx.get_edge_attributes(G, 'desc')
        nx.draw_networkx_edge_labels(G, pos, font_size=6, font_family='Times New Roman', edge_labels=edge_labels)
        nx.draw_networkx_nodes(G, pos, node_size=800, node_color=nodes_color_list, alpha=0.3)
        nx.draw_networkx_edges(G, pos, node_size=800, width=0.8, arrows=True, arrowstyle="->",
                               arrowsize=13, alpha=0.8, label=True)

        if show_fig: plt.show()
        if save_fig: plt.savefig(save_fig_path)
        plt.close()  # https://blog.csdn.net/daixiangzi/article/details/82528927
        self.G = G  # 存储graph至该对象

    def generate_new_url_graph_without_src(self, src):
        """
        src=N,R,D,G
        这里仅仅是删除包含 src的边，对于子节点，有些是不删除的，是个bug；不过，对于CVE-》 patch联通度计算时，不影响， 因为无联通的path！
        """
        self.url_graph_without_src = copy.deepcopy(self)
        # self.url_graph_without_src.visualise_graph(show_fig=True)
        if src:
            # 删除所有含src的边
            for edge_item_index in range(len(self.url_graph_without_src.edges_list)).__reversed__():
                edge_item = self.url_graph_without_src.edges_list[edge_item_index]
                if src in edge_item:
                    child_node_id = edge_item[-1]
                    self.url_graph_without_src.edges_list.remove( edge_item )
                    # # 递归删去：src的单一子节点，即：只有src为父节点的子节点
                    # # 判断，该子节点是否还有父节点 == 该节点，仅作为子节点
                    # all_parents_nodes_str = [ ele[0] for ele in self.url_graph_without_src.edges_list ].__str__()
                    # all_child_nodes_str = [ ele[-1] for ele in self.url_graph_without_src.edges_list ].__str__()
                    # if child_node_id in all_parents_nodes_str and not in all_child_nodes_str:
            edges_str = self.url_graph_without_src.edges_list.__str__()
            # 判断所有节点，是否在某个边中，不再的话，即删除！
            for index in range(len(self.url_graph_without_src.node_id_list)).__reversed__() :
                node_id = self.url_graph_without_src.node_id_list[index]
                if "'"+node_id+"'" in edges_str: # 不然的话，像 N 太容易在字符串中了，加个隐号，规避一下！
                    pass
                else:
                    self.url_graph_without_src.nodes.pop(index)
                    self.url_graph_without_src.node_id_list.pop(index)
        self.url_graph_without_src.build_graph() # 构建新的self.G,必须要有，不能删除！
        # self.url_graph_without_src.visualise_graph(show_fig=True)  # 构建新的self.G
        # url_graph_without_EX = copy.deepcopy(self.url_graph_without_EX)
        return self.url_graph_without_src

    def print_root(self):
        print(self.root_node.formatted_id)

    def get_NVD_ref_and_SG_patch_node(self, nodes):
        """ 获取NVD直接相连的patch node """
        selected_nodes = []
        # ('N', 1, None, 'http://www.securityfocus.com/bid/103766')
        # ('CVE-2018-0737', None, 'SG', '8654a2')
        for node in nodes:
            formatted_id = node.formatted_id
            # N
            edge_item = ('N' , 1, None, formatted_id)
            if edge_item in  self.edges_list :
                selected_nodes.append( node )
            # SG
            edge_item = (self.root_node.formatted_id, None, 'SG', formatted_id)
            if edge_item in  self.edges_list :
                selected_nodes.append( node )
        return selected_nodes

    def compute_graph(self): # test
        from networkx.algorithms import approximation as approx
        from networkx.algorithms import simple_paths
        # self.visualise_graph(show_fig=True)
        # res = simple_paths.all_simple_paths( self.G, 'CVE-2013-6450', 'https://github.com/openssl/openssl/commit/ea39b16b71e4e72a228a4535bd6d6a02c5edbc1f'  )
        # res = simple_paths.all_simple_paths(self.G, 'CVE-2013-6450','ea39b1')
        res = simple_paths.all_simple_paths(self.G, 'CVE-2018-11798', '2a2b72')
        for path in res:
            print(path)
        # res = approx.local_node_connectivity(self.G, 'CVE-2018-11798', 'https://github.com/apache/thrift/commit/2a2b72',cutoff=5)
        # print("res 2a2b72", res)
        # res = approx.local_node_connectivity(self.G, 'CVE-2018-11798', 'N',cutoff=5)
        # print("res github.com__fdse__1606", res)
        # res = approx.local_node_connectivity(self.G, 'CVE-2018-11798', 'https://github.com/apache/thrift/commit/2a2b72',cutoff=5)
        # print("res 2a2b72",res)
        # print(self.G.degree()['https://github.com/apache/thrift/commit/2a2b72'])
        # res = approx.local_node_connectivity(self.G, 'CVE-2018-11798', 'https://github.com/apache/thrift/commit/cfa52d',cutoff=5)
        # print("res cfa52d", res)
        # res = approx.local_node_connectivity(self.G, 'CVE-2018-11798', 'https://github.com/apache/thrift/commit/7a5e21',cutoff=5)
        # print("res 7a5e21", res)
        #
        # res = approx.local_node_connectivity(self.G, 'CVE-2018-11798', 'issues.apache.org__fdse__THRIFT-4647',cutoff=5)
        # print("res issues.apache.org__fdse__THRIFT-4647", res)
        # res = approx.local_node_connectivity(self.G, 'CVE-2018-11798', 'github.com__fdse__1606',cutoff=5)
        # print("res github.com__fdse__1606", res)


        # print( self.G['https://github.com/apache/thrift/commit/2a2b72'] )
        # print( list(nx.connected_components(self.G)) )

        # for n, d in self.G.degree():
        #     print(n,d)
        # print( sorted(d for n, d in self.G.degree()) )
        # print( nx.clustering(self.G) )

if __name__ == '__main__':
    CVEID = 'CVE-2018-15727' # 'CVE-2018-11798' # 'CVE-2014-4611' 'CVE-2016-6298' 'CVE-2016-10127'  'CVE-2009-0217' 'CVE-2018-1000169' 'CVE-2010-0156'
    recommended_patch = evaluate.generate_localized_CVE_patch_result(CVEID)[CVEID]
    print( CVEID )
    print( [ ele.formatted_id for ele in recommended_patch] )


    # a = Graph()
    # a.root_node = '1'
    # b = Graph()
    # b.root_node = '2'
    #
    # print(a.root_node , b.root_node , Graph.root_node)
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
-----------------------------------------
@Created: 2021/02/24
------------------------------------------
@Modify: 2021/02/24
------------------------------------------
@Description:
用于验证patch localization effectiveness

1. 读取GT 内容，根据 CVEID、branch等组织数据结构
2. 获取localized CVE-patch
3. compare(localized_patch, ground-truth)

main_evaluate_vulnerabilityDB():
All branches: top[:500]
Veracode {'precision': 0.8847252747252746, 'recall': 0.7526275007044236}
CVEID_not_in_vuldb:  13
CVEID_not_in_GT:  32

Snyk {'precision': 0.8955916473317864, 'recall': 0.7504757230395286}
CVEID_not_in_vuldb:  37
CVEID_not_in_GT:  32

Gitlab {'precision': 0.8963414634146342, 'recall': 0.7148373983739837}
CVEID_not_in_vuldb:  386
CVEID_not_in_GT:  32

CVEID_not_in_our_db:  48
CVEID_not_in_GT:  32
our tool {'precision': 0.35989090908572446, 'recall': 0.8334155328798187}
"""
import os, sys, re

_PROJECT_NAME = 'VulnerabilityAnalysis'
_CURRENT_ABSPATH = os.path.abspath(__file__)
sys.path.insert(0, _CURRENT_ABSPATH[:_CURRENT_ABSPATH.find(_PROJECT_NAME) + len(_PROJECT_NAME)])

from vulnerability_analysis import config
from vulnerability_analysis.utility import json_processing, file_processing
from vulnerability_analysis.patch_localization.tool import cls_node
from vulnerability_analysis.utility import re_util, log
import pickle, logging
import urllib.parse
import multiprocessing
# cdb.quit_selenium_crawler()  # 关闭chromedriver, 减少进程开销

l1_split_str = config.L1_SPLITE_STR
logger = log.create_logger(level=logging.INFO, log_file_path=config.PATCH_LOCALICATION_OUTPUT_EVALUATE_PATH,
                           logger_name='evaluate', print_stream_cmd=True)
log_content = file_processing.read_TXTfile(config.PATCH_LOCALICATION_OUTPUT_EVALUATE_PATH)

formal_GT = {}  # 全局GT
GT_classification_info = ''  # 全局GT分类信息

import os

os.environ['OPENBLAS_NUM_THREADS'] = '2'

# 甚至想放入uncertain中
# CVEID_not_todo_list = ['CVE-2013-4939', 'CVE-2013-4940', 'CVE-2013-4941', 'CVE-2013-4942', 'CVE-2017-14695',
#                        'CVE-2017-14696', 'CVE-2017-7657', 'CVE-2018-12538', 'CVE-2019-0201', 'CVE-2020-1938',
#                        'CVE-2019-9658']

CVEID_not_todo_list = []

# Uncertain_5000_100 = ['CVE-2010-4207','CVE-2016-3716','CVE-2011-4940'] # 不全
Uncertain_5000_100 = ['CVE-2013-5943', 'CVE-2011-4462', 'CVE-2016-3716', 'CVE-2012-0805', 'CVE-2015-7704', 'CVE-2019-9517', 'CVE-2011-4153', 'CVE-2014-9840', 'CVE-2010-4207', 'CVE-2016-2049', 'CVE-2011-4940']
uncertain_3000_100 =  ['CVE-2018-11770', 'CVE-2017-17458', 'CVE-2019-10782', 'CVE-2011-4356', 'CVE-2011-5062', 'CVE-2014-9837',
                       'CVE-2017-9050','CVE-2014-9819','CVE-2014-0074' ]

# 1: 验证1k的GT， 3：验证3k的GT，5： 验证5k的数据
switch_GT_rvaluation = 1

def load_ground_truth():
    import csv
    # read
    GT_csv = []
    GT_path_XCY = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_XCY.csv'
    GT_path_LCH = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_LCH.csv'
    GT_path_LCH_LY = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_LCH_LY.csv'
    GT_path_Uncertain = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_Uncertain.csv'
    experimental_CVEIDs_VS_interaction_with_patch_path = config.DATA_PATH + 'patch_localization/experimental_CVEIDs_VS_interaction_with_patch_path.json'
    experimental_CVEIDs_VS_interaction_with_patch_cve_list = json_processing.read(path=experimental_CVEIDs_VS_interaction_with_patch_path)

    GT_5000_100 = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_5000_100.csv'
    GT_3000_100 = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_3000_100.csv'
    Uncertain_CVEID_list = []
    if switch_GT_rvaluation==1:
        with open(GT_path_LCH_LY, 'r') as f:
            GT_csv_reader = csv.reader(f)
            for row in GT_csv_reader:
                GT_csv.append(row)
        with open(GT_path_XCY, 'r') as f:
            GT_csv_reader = csv.reader(f)
            for row in GT_csv_reader:
                GT_csv.append(row)
        with open(GT_path_LCH, 'r') as f:
            GT_csv_reader = csv.reader(f)
            for row in GT_csv_reader:
                GT_csv.append(row)
    elif switch_GT_rvaluation==3:
        with open(GT_3000_100, 'r') as f:
            GT_csv_reader = csv.reader(f)
            for row in GT_csv_reader:
                GT_csv.append(row)
    elif switch_GT_rvaluation==5:
        with open(GT_5000_100, 'r') as f:
            GT_csv_reader = csv.reader(f)
            for row in GT_csv_reader:
                GT_csv.append(row)
    with open(GT_path_Uncertain, 'r', encoding='utf-8') as f:
        GT_csv_reader = csv.reader(f)
        for row in GT_csv_reader:
            CVEID = row[2]
            if CVEID.startswith('CVE-'):
                Uncertain_CVEID_list.append(CVEID)

    print("Read Done!")
    Uncertain_CVEID_list = list(set(Uncertain_CVEID_list))
    print(len(Uncertain_CVEID_list))
    # process
    # 1. 提取所有commit，并按branch分类
    global formal_GT, GT_classification_info
    raw_GT = {}
    # formal_GT = {} # {CVEID: branch:patch:[properties]}
    for row in GT_csv:  # 因为第一行为title
        CVEID, svn_commit, other_git_commit, github_commit, equivalent, branch, external_repo, github_PR, PR_status, PR_commits, merged_commits, related_commit \
            = row[1], row[2], row[3], row[4], row[5], row[6], row[7], row[8], row[9], row[10], row[11], row[12]
        branch = row[6].split(' (#')[0].split(' ')[0].split('(')[0].split('（#')[0].split(' （#')[0].split(' （#')[
            0]  # 格式化一下branch名称
        if CVEID in Uncertain_CVEID_list:
            continue
        if CVEID not in raw_GT: raw_GT[CVEID] = {}
        if branch:
            if branch not in raw_GT[CVEID]: raw_GT[CVEID][branch] = []
            raw_GT[CVEID][branch].append(row)
        if branch == '':
            if 'not_specified' not in raw_GT[CVEID]: raw_GT[CVEID]['not_specified'] = []
            raw_GT[CVEID]['not_specified'].append(row)
    # 2. 合并等价的false分支，并生成all branches
    for CVEID in raw_GT:
        if not CVEID.startswith('CVE-'): continue
        # 不在 valid CVE list中
        if switch_GT_rvaluation==1 and  CVEID not in experimental_CVEIDs_VS_interaction_with_patch_cve_list: continue

        formal_GT[CVEID] = {}
        # 合并等价的false分支，
        if 'FALSE' in raw_GT[CVEID].keys():
            for patch_item in raw_GT[CVEID]['FALSE']:
                patch_content = patch_item[2] + patch_item[3] + patch_item[4]
                unified_patch_content = unify_patch_format_for_evalution([patch_content])[0]
                equivalent = patch_item[5]
                hit_flag = 0  # 用于标示，是否命中等价项
                # 遍历其他branch
                for branch_key in raw_GT[CVEID].keys():
                    if hit_flag == 1 or 'FALSE' in branch_key: continue  # 排除 'FALSE' branch
                    for patch_item_b in raw_GT[CVEID][branch_key]:
                        patch_content_b = patch_item_b[2] + patch_item_b[3] + patch_item_b[4]
                        equivalent_b = patch_item_b[5]
                        unified_patch_content_b = unify_patch_format_for_evalution([patch_content_b])[0]
                        if unified_patch_content in equivalent_b or unified_patch_content_b in equivalent:  # 命中等价项
                            raw_GT[CVEID][branch_key].append(patch_item)
                            raw_GT[CVEID]['FALSE'].remove(patch_item)
                            hit_flag = 1
                            break
            if len(raw_GT[CVEID]['FALSE']) == 0:  # 说明都已移至其他等价branch
                raw_GT[CVEID].pop('FALSE')
        # 生成all branches
        formal_GT[CVEID]['all_branches'] = []
        for branch_key in raw_GT[CVEID].keys():
            formal_GT[CVEID][branch_key] = raw_GT[CVEID][branch_key]
            formal_GT[CVEID]['all_branches'] += raw_GT[CVEID][branch_key]
    # 3. 基于patch组成，将CVE进行分类
    GT_classification_info = {'single_P': [], 'single_PG': [], 'multiple_PGs_but_single_branch': [],
                              'multiple_PGs_and_branches': []}
    for CVEID in formal_GT:
        branch_num = len(formal_GT[CVEID].keys())
        if branch_num == 2:  # 说明是单branch
            if len(formal_GT[CVEID]['all_branches']) == 1:  # 仅一个patch
                # GT_classification_info['single_PG'].append(CVEID  )
                GT_classification_info['single_P'].append(CVEID)
            else:  # 多个patch， 判断是否为single patch group
                non_equivalent_items = []
                for patch_item in formal_GT[CVEID]['all_branches']:  # 取all_branches中的数据进行判断
                    equivalent = patch_item[5]
                    if len(equivalent) < 5:  # 说明为空
                        patch_content = patch_item[2] + patch_item[3] + patch_item[4]
                        non_equivalent_items.append(unify_patch_format_for_evalution([patch_content])[0])
                # 确实一下，是否为其他项的等价项
                if non_equivalent_items:
                    for patch_item in formal_GT[CVEID]['all_branches']:  # 取all_branches中的数据进行判断
                        equivalent = patch_item[5]
                        for non_equivalent_item in non_equivalent_items:
                            if non_equivalent_item in equivalent:
                                non_equivalent_items.remove(non_equivalent_item)
                if len(non_equivalent_items) > 0:  # 说明是多个patch group
                    GT_classification_info['multiple_PGs_but_single_branch'].append(CVEID)
                else:
                    GT_classification_info['single_PG'].append(CVEID)
        else:  # 多branch
            GT_classification_info['multiple_PGs_and_branches'].append(CVEID)
    return formal_GT, GT_classification_info

def load_ground_truth_with_new_classification():
    import csv
    # read
    GT_csv = []
    GT_path_XCY = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_XCY.csv'
    GT_path_LCH = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_LCH.csv'
    GT_path_LCH_LY = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_LCH_LY.csv'
    GT_path_Uncertain = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_Uncertain.csv'
    experimental_CVEIDs_VS_interaction_with_patch_path = config.DATA_PATH + 'patch_localization/experimental_CVEIDs_VS_interaction_with_patch_path.json'
    experimental_CVEIDs_VS_interaction_with_patch_cve_list = json_processing.read(
        path=experimental_CVEIDs_VS_interaction_with_patch_path)

    GT_5000_100 = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_5000_100.csv'
    GT_3000_100 = config.PROJECT_ROOT + 'doc/patch localization/RQ3 the accuarcy of DBs/GT_3000_100.csv'
    Uncertain_CVEID_list = []
    if switch_GT_rvaluation == 1:
        with open(GT_path_LCH_LY, 'r') as f:
            GT_csv_reader = csv.reader(f)
            for row in GT_csv_reader:
                GT_csv.append(row)
        with open(GT_path_XCY, 'r') as f:
            GT_csv_reader = csv.reader(f)
            for row in GT_csv_reader:
                GT_csv.append(row)
        with open(GT_path_LCH, 'r') as f:
            GT_csv_reader = csv.reader(f)
            for row in GT_csv_reader:
                GT_csv.append(row)
    elif switch_GT_rvaluation == 3:
        with open(GT_3000_100, 'r') as f:
            GT_csv_reader = csv.reader(f)
            for row in GT_csv_reader:
                GT_csv.append(row)
    elif switch_GT_rvaluation == 5:
        with open(GT_5000_100, 'r') as f:
            GT_csv_reader = csv.reader(f)
            for row in GT_csv_reader:
                GT_csv.append(row)
    with open(GT_path_Uncertain, 'r', encoding='utf-8') as f:
        GT_csv_reader = csv.reader(f)
        for row in GT_csv_reader:
            CVEID = row[2]
            if CVEID.startswith('CVE-'):
                Uncertain_CVEID_list.append(CVEID)

    print("Read Done!")
    Uncertain_CVEID_list = list(set(Uncertain_CVEID_list))
    print(len(Uncertain_CVEID_list))

    # process
    # 1. 提取所有commit，并按branch分类
    formal_GT = {}
    raw_GT = {}
    existing_svn_CVEID_set = set()
    existing_other_git_CVEID_set = set()
    # formal_GT = {} # {CVEID: branch:patch:[properties]}
    for row in GT_csv:  # 因为第一行为title
        # print(len(row),row)
        CVEID, svn_commit, other_git_commit, github_commit, equivalent, branch, external_repo, github_PR, PR_status, PR_commits, merged_commits, repo_name \
            = row[1], row[2], row[3], row[4], row[5], row[6], row[7], row[8], row[9], row[10], row[11], row[12]
        branch = row[6].split(' (#')[0].split(' ')[0].split('(')[0].split('（#')[0].split(' （#')[0].split(' （#')[
            0]  # 格式化一下branch名称
        if CVEID in Uncertain_CVEID_list: continue
        if CVEID not in raw_GT: raw_GT[CVEID] = {}
        if repo_name not in raw_GT[CVEID]: raw_GT[CVEID][repo_name] = {}

        if branch == '':
            branch = 'not_specified'
        if branch not in raw_GT[CVEID][repo_name]: raw_GT[CVEID][repo_name][branch] = []
        raw_GT[CVEID][repo_name][branch].append(row)

        if len(svn_commit) > 2:
            existing_svn_CVEID_set.add(CVEID)
        if len(other_git_commit) > 2:
            existing_other_git_CVEID_set.add(CVEID)

    # 2. 合并等价的false分支，并生成all branches
    # + 合并svn/
    # todo，  other git 分支
    for CVEID in raw_GT:
        if not CVEID.startswith('CVE-'): continue
        # 不在 valid CVE list中
        if switch_GT_rvaluation==1 and CVEID not in experimental_CVEIDs_VS_interaction_with_patch_cve_list: continue

        formal_GT[CVEID] = {}
        for repo_name in raw_GT[CVEID].keys():
            formal_GT[CVEID][repo_name] = {}
            # 合并等价的false分支，
            if 'FALSE' in raw_GT[CVEID][repo_name].keys():
                # todo,传递性合并false分支；如CVE-2013-2172
                for patch_item in raw_GT[CVEID][repo_name]['FALSE']:
                    patch_content = patch_item[2] + patch_item[3] + patch_item[4]
                    unified_patch_content = unify_patch_format_for_evalution([patch_content])[0]
                    equivalent = patch_item[5]
                    hit_flag = 0  # 用于标示，是否命中等价项
                    # 遍历其他branch
                    for branch_key in raw_GT[CVEID][repo_name].keys():
                        if hit_flag == 1 or 'FALSE' in branch_key: continue  # 排除：已hit / 'FALSE' branch
                        for patch_item_b in raw_GT[CVEID][repo_name][branch_key]:
                            patch_content_b = patch_item_b[2] + patch_item_b[3] + patch_item_b[4]
                            equivalent_b = patch_item_b[5]
                            unified_patch_content_b = unify_patch_format_for_evalution([patch_content_b])[0]
                            if unified_patch_content in equivalent_b or unified_patch_content_b in equivalent:  # 命中等价项
                                raw_GT[CVEID][repo_name][branch_key].append(patch_item)
                                raw_GT[CVEID][repo_name]['FALSE'].remove(patch_item)
                                hit_flag = 1
                                break
                if len(raw_GT[CVEID][repo_name]['FALSE']) == 0:  # 说明都已移至其他等价branch
                    raw_GT[CVEID][repo_name].pop('FALSE')
            # 合并等价svn，至其他等价commit分支。todo, 未完成！
            # if this_CVEID_existing_svn_commit==1:
            #     existing_svn_CVEID_set.add(CVEID)
            #     for branch_original in raw_GT[CVEID][repo_name].keys():
            #         for patch_item in raw_GT[CVEID][repo_name][branch_original]:
            #             if len(patch_item[2]) < 2: continue # 说明不是svn
            #             patch_content = patch_item[2] + patch_item[3] + patch_item[4]
            #             unified_patch_content = unify_patch_format_for_evalution([patch_content])[0]
            #             equivalent = patch_item[5]
            #             hit_flag = 0  # 用于标示，是否命中等价项
            #             # 遍历其他branch
            #             for branch_key in raw_GT[CVEID][repo_name].keys():
            #                 if hit_flag == 1 or branch_original in branch_key: continue  # 排除：已hit / 自身 branch
            #                 for patch_item_b in raw_GT[CVEID][repo_name][branch_key]:
            #                     patch_content_b = patch_item_b[2] + patch_item_b[3] + patch_item_b[4]
            #                     equivalent_b = patch_item_b[5]
            #                     unified_patch_content_b = unify_patch_format_for_evalution([patch_content_b])[0]
            #                     if unified_patch_content in equivalent_b or unified_patch_content_b in equivalent:  # 命中等价项
            #                         raw_GT[CVEID][repo_name][branch_key].append(patch_item)
            #                         raw_GT[CVEID][repo_name][branch_original].remove(patch_item)
            #                         hit_flag = 1
            #                         break
            # 生成all branches
            formal_GT[CVEID][repo_name]['all_branches'] = []
            for branch_key in raw_GT[CVEID][repo_name].keys():
                formal_GT[CVEID][repo_name][branch_key] = raw_GT[CVEID][repo_name][branch_key]
                formal_GT[CVEID][repo_name]['all_branches'] += raw_GT[CVEID][repo_name][branch_key]

    # 3. 基于patch组成，将CVE进行分类
    GT_classification_info = {'single_P': [], 'single_PG': [], 'multiple_PGs_but_single_branch': [],
                              'multiple_PGs_and_branches': [], 'multiple_repos': []}
    false_multiple_repos_cnt = 0
    for CVEID in formal_GT:
        repo_num = len(formal_GT[CVEID].keys())
        if repo_num > 1:
            GT_classification_info['multiple_repos'].append(CVEID)
            if 'toadd' in formal_GT[CVEID].keys() and repo_num == 2:
                false_multiple_repos_cnt += 1
            continue

        # 单repo：
        repo_name = list(formal_GT[CVEID].keys())[0]
        branch_num = len(formal_GT[CVEID][repo_name].keys())
        if branch_num == 2:  # 说明是单branch
            if len(formal_GT[CVEID][repo_name]['all_branches']) == 1:  # 仅一个patch
                # GT_classification_info['single_PG'].append(CVEID  )
                GT_classification_info['single_P'].append(CVEID)
            else:  # 多个patch， 判断是否为single patch group
                non_equivalent_items = []
                for patch_item in formal_GT[CVEID][repo_name]['all_branches']:  # 取all_branches中的数据进行判断
                    equivalent = patch_item[5]
                    if len(equivalent) < 5:  # 说明为空
                        patch_content = patch_item[2] + patch_item[3] + patch_item[4]
                        non_equivalent_items.append(unify_patch_format_for_evalution([patch_content])[0])
                # 确实一下，是否为其他项的等价项
                if non_equivalent_items:
                    for patch_item in formal_GT[CVEID][repo_name]['all_branches']:  # 取all_branches中的数据进行判断
                        equivalent = patch_item[5]
                        for non_equivalent_item in non_equivalent_items:
                            if non_equivalent_item in equivalent:
                                non_equivalent_items.remove(non_equivalent_item)
                if len(non_equivalent_items) > 0:  # 说明是多个patch group
                    GT_classification_info['multiple_PGs_but_single_branch'].append(CVEID)
                else:
                    GT_classification_info['single_PG'].append(CVEID)
        else:  # 多branch
            GT_classification_info['multiple_PGs_and_branches'].append(CVEID)

    # print(len(GT_classification_info['single_P']),GT_classification_info['single_P'])
    # print(len(GT_classification_info['single_PG']), GT_classification_info['single_PG'])
    # print(len(GT_classification_info['multiple_PGs_but_single_branch']), GT_classification_info['multiple_PGs_but_single_branch'])
    # print(len(GT_classification_info['multiple_PGs_and_branches']), GT_classification_info['multiple_PGs_and_branches'])
    # print(len(GT_classification_info['multiple_repos']), GT_classification_info['multiple_repos'])
    # print('false_multiple_repos_cnt:', false_multiple_repos_cnt)
    # print('existing_svn_CVEID_set', len(existing_svn_CVEID_set))
    # print('existing_other_git_CVEID_set', len(existing_other_git_CVEID_set))
    # json_processing.write(json_content=formal_GT, path='formal_GT.json')

    return formal_GT, GT_classification_info

def read_cve_patch_result(CVEID):
    cve_patches_obj = None
    PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH = config.PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH % CVEID
    with open(PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH, 'rb') as f:
        return pickle.loads(f.read())

def generate_localized_CVE_patch_result(CVEID):
    # 初始化
    cve_patches_obj = read_cve_patch_result(CVEID)
    # cve_patches_obj.url_graph.compute_graph() # for debug
    rules = {'src': ['all'], 'searched_entities': ['all'], 'patch_type': ['git_commit', 'svn'],
             'patch_content': ['only_code_change',
                               'cutoff=4']}  # valid_patch_url ,'only_code_change', 'patch_date', 'only_target_CPEs',
    # 提取符合条件的所有patch node
    cve_patches_obj.url_graph.build_graph()  # 以防未加载 G信息
    selected_patch_nodes = cve_patches_obj.url_graph.get_patches_by_rules(rules=rules)
    selected_patch_ids = [ele_node.formatted_id for ele_node in selected_patch_nodes]

    # 先过滤出 EX patch
    # cve_patches_obj.url_graph.print_root()
    non_ex_patch_nodes = cve_patches_obj.url_graph.filter_out_only_EX_patch_nodes(nodes=selected_patch_nodes)
    url_graph_without_EX = cve_patches_obj.url_graph.generate_new_url_graph_without_EX()

    candidate_patch_nodes = []
    priority_rules = 'CN'  # 'DG&DP' 'DG&C' 'DG':degree 'C':approx.local_node_connectivity 'DP':depth ‘CN‘:'connectivity'
    if priority_rules:
        cve_patches_obj.url_graph.build_graph()  # 以防未加载 G信息
        # # 先用DP进行过滤，限制在top1 / 2的node，再计算 CN数值，减少时间消耗; 因为CN的top node，应该也在 低层；所以，因为不会有太多计算误差
        # if priority_rules == 'CN':
        #     node_priority_info, node_priority_list = cve_patches_obj.url_graph.compute_the_priority_of_nodes(nodes=non_ex_patch_nodes, rules='DP')
        #     # 获得priority_list
        #     if node_priority_list:
        #         max_priority = 0 # 实为阈值
        #         if len(node_priority_list) > 2:
        #             max_priority = sorted( node_priority_list ) [-3]
        #         else:
        #             max_priority = sorted(node_priority_list)[-1]
        #         non_ex_patch_nodes = [node for node in node_priority_info if node_priority_info[node] >= max_priority]
        # 基于priority选择patch node
        node_priority_info, node_priority_list = url_graph_without_EX.compute_the_priority_of_nodes(
            nodes=non_ex_patch_nodes, rules=priority_rules)
        # node_priority_info, node_priority_list = cve_patches_obj.url_graph.compute_the_priority_of_nodes(
        #     nodes=non_ex_patch_nodes, rules=priority_rules)
        # 获得priority_list
        if node_priority_list:
            # if priority_rules == 'CN':
            #     threshold_value = 1.0
            #     candidate_patch_nodes = [node for node in node_priority_info if node_priority_info[node] >= threshold_value]
            # else:
            # for node in node_priority_info:
            #     print(node.formatted_id, node_priority_info[node])
            max_priority = max(node_priority_list)
            candidate_patch_nodes = [node for node in node_priority_info if node_priority_info[node] >= max_priority]
            # 增加一项~, SG + NVD_ref_patch
            candidate_patch_nodes.extend(url_graph_without_EX.get_NVD_ref_and_SG_patch_node(nodes=non_ex_patch_nodes))
    else:
        candidate_patch_nodes = non_ex_patch_nodes
    selected_patch_nodes = []
    selected_patch_nodes.extend(candidate_patch_nodes)  # 防止直接是对象地址赋值，就会比较尴尬
    # 增加 ‘EX' 的patch
    EXtension_rule = True
    if EXtension_rule:
        candidate_patch_nodes = list(set(candidate_patch_nodes))
        # if priority_rules == 'CN': # 先实现，向上搜索；搜索hitted_nodes 最小层数相同或以上的节点，解决multiple patches问题
        #     candidate_patch_nodes.extend( url_graph_without_EX.get_patch_nodes_with_less_depth(  base_line_nodes=candidate_patch_nodes, all_candidate_nodes=non_ex_patch_nodes, equal=True ) )
        # candidate_patch_nodes.extend( url_graph_without_EX.get_patch_nodes_with_same_parent_nodes(  base_line_nodes=candidate_patch_nodes, all_candidate_nodes=non_ex_patch_nodes ) )
        #     # get_patch_nodes_with_same_parent_nodes
        #     # candidate_patch_nodes.extend(cve_patches_obj.url_graph.get_patch_nodes_with_same_parent_nodes(base_line_nodes=candidate_patch_nodes,all_candidate_nodes=non_ex_patch_nodes))
        candidate_patch_nodes = list(set(candidate_patch_nodes))
        selected_patch_nodes.extend(candidate_patch_nodes)
        for can_patch_node in candidate_patch_nodes:
            # EX_child_nodes = cve_patches_obj.url_graph.get_direct_and_indirect_nodes_with_EX(can_patch_node)
            EX_child_nodes = cve_patches_obj.url_graph.get_direct_nodes_with_EX(can_patch_node)
            for EX_child_node in EX_child_nodes:
                if EX_child_node.formatted_id in selected_patch_ids:  # 说明是满足patch选取rule的
                    selected_patch_nodes.append(EX_child_node)
                    # candidate_patch_nodes.extend( EX_child_nodes )
        selected_patch_nodes = list(set(selected_patch_nodes))
    return {CVEID: selected_patch_nodes}

def generate_localized_CVE_patch_result_with_rules(CVEID, rules):
    """
    rules = {'src': ['all'], 'priority': 'CN', 'select_add_SG_N': True , 'Extension': 30 , 'searched_entities': ['all'], 'patch_type': ['git_commit', 'svn'], 'patch_content': ['only_code_change','cutoff=4']}  # valid_patch_url ,'only_code_change', 'patch_date', 'only_target_CPEs',
    src: ['all'] , ['withoutR'], ['withoutD'], ['withoutN'], ['withoutG']
    priority: None, 'CN', 'DP', 'DG' (toadd CN不同算法的选项)
    select_add_SG_N: True / False
    Extension: None, int(days)

    :param CVEID:
    :param rules:
    :return:
    """
    # 初始化
    cve_patches_obj = read_cve_patch_result(CVEID)
    # cve_patches_obj.url_graph.compute_graph() # for debug
    # rules = {'src': ['all'], 'priority': 'CN', 'Extension': 30 , 'searched_entities': ['all'], 'patch_type': ['git_commit', 'svn'], 'patch_content': ['only_code_change','cutoff=4']}  # valid_patch_url ,'only_code_change', 'patch_date', 'only_target_CPEs',
    # 提取符合条件的所有patch node
    cve_patches_obj.url_graph.build_graph()  # 以防未加载 G信息
    # cve_patches_obj.url_graph.visualise_graph(show_fig=True)
    if rules['src'] == ['withoutN']:
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='N')
    elif rules['src'] == ['withoutR']:
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='R')
    elif rules['src'] == ['withoutD']:
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='D')
    elif rules['src'] == ['withoutG']:
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='SG')
    elif sorted(rules['src']) == sorted(['withoutR', 'withoutD']):
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='D')
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='R')
    elif sorted(rules['src']) == sorted(['withoutG', 'withoutR', 'withoutD']):
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='SG')
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='D')
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='R')
    elif sorted(rules['src']) == sorted(['withoutN', 'withoutR', 'withoutD']):
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='N')
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='D')
        cve_patches_obj.url_graph = cve_patches_obj.url_graph.generate_new_url_graph_without_src(src='R')

    # cve_patches_obj.url_graph.build_graph()  # 以防未加载 G信息
    if CVEID not in cve_patches_obj.url_graph.node_id_list:  # 甚至连CVE节点都没有了
        print(CVEID, 'no patch')
        return {CVEID: []}
    selected_patch_nodes = cve_patches_obj.url_graph.get_patches_by_rules(rules=rules)
    selected_patch_ids = [ele_node.formatted_id for ele_node in selected_patch_nodes]

    # 先过滤出 EX patch
    # cve_patches_obj.url_graph.print_root()
    non_ex_patch_nodes = cve_patches_obj.url_graph.filter_out_only_EX_patch_nodes(nodes=selected_patch_nodes)
    url_graph_without_EX = cve_patches_obj.url_graph.generate_new_url_graph_without_EX()

    candidate_patch_nodes = []
    priority_rules = rules[
        'priority']  # 'DG&DP' 'DG&C' 'DG':degree 'C':approx.local_node_connectivity 'DP':depth ‘CN‘:'connectivity'
    if priority_rules:
        cve_patches_obj.url_graph.build_graph()  # 以防未加载 G信息
        cutoff_num = 4  # 提取rule中的cutoff数值
        for ele in rules['patch_content']:
            if 'cutoff' in ele:
                cutoff_num = int(ele.split('=')[-1])
        # 基于priority选择patch node
        node_priority_info, node_priority_list = url_graph_without_EX.compute_the_priority_of_nodes(
            nodes=non_ex_patch_nodes, rules=priority_rules, CN_cutoff=cutoff_num)
        # 获得priority_list
        if node_priority_list:
            max_priority = max(node_priority_list)
            candidate_patch_nodes = [node for node in node_priority_info if node_priority_info[node] >= max_priority]
            # 增加一项~, SG + NVD_ref_patch
            if rules['select_add_SG_N']:
                candidate_patch_nodes.extend(
                    url_graph_without_EX.get_NVD_ref_and_SG_patch_node(nodes=non_ex_patch_nodes))
    elif not priority_rules and  rules['select_add_SG_N']:
        candidate_patch_nodes.extend(
            url_graph_without_EX.get_NVD_ref_and_SG_patch_node(nodes=non_ex_patch_nodes))
    else:
        candidate_patch_nodes = non_ex_patch_nodes
    selected_patch_nodes = []
    selected_patch_nodes.extend(candidate_patch_nodes)  # 防止直接是对象地址赋值，就会比较尴尬
    selected_patch_nodes = list(set(selected_patch_nodes))
    # 增加 ‘EX' 的patch
    EXtension_rule = rules['Extension']
    if EXtension_rule or EXtension_rule == 0:
        candidate_patch_nodes = list(set(candidate_patch_nodes))
        candidate_patch_nodes = list(set(candidate_patch_nodes))
        selected_patch_nodes.extend(candidate_patch_nodes)
        for can_patch_node in candidate_patch_nodes:
            # EX_child_nodes = cve_patches_obj.url_graph.get_direct_and_indirect_nodes_with_EX(can_patch_node)
            EX_child_nodes = cve_patches_obj.url_graph.get_direct_nodes_with_EX(can_patch_node,
                                                                                days_span=rules['Extension'], valid_expansion_message=rules['valid_expansion_message'])
            for EX_child_node in EX_child_nodes:
                if EX_child_node.formatted_id in selected_patch_ids:  # 说明是满足patch选取rule的
                    selected_patch_nodes.append(EX_child_node)
                    # candidate_patch_nodes.extend( EX_child_nodes )
        selected_patch_nodes = list(set(selected_patch_nodes))

    if 'limited_patch_num' in rules.keys() and rules['limited_patch_num']:
        if len(selected_patch_nodes) > rules['limited_patch_num']:
            selected_patch_nodes = []
    return {CVEID: selected_patch_nodes}

def generate_localized_CVE_patch_result_of_CVEIDs():
    # CVEID_list:  5487
    # CVE_patch_pairs.keys() 2963
    # PATCH_LOCALIZATION_EXPERIMENTAL_CVEIDS_WITHOUT_PATCH = config.PATCH_LOCALIZATION_EXPERIMENTAL_CVEIDS_WITHOUT_PATCH
    # CVEID_list = json_processing.read(path=PATCH_LOCALIZATION_EXPERIMENTAL_CVEIDS_WITHOUT_PATCH)

    PATCH_LOCALIZATION_EXPERIMENTAL_CVEIDS_WITH_PATCH_IN_ONLY_ONE_DB = config.PATCH_LOCALIZATION_EXPERIMENTAL_CVEIDS_WITH_PATCH_IN_ONLY_ONE_DB
    CVEID_list = json_processing.read(path=PATCH_LOCALIZATION_EXPERIMENTAL_CVEIDS_WITH_PATCH_IN_ONLY_ONE_DB)

    # bozhi
    # bozhi_json_data, CVEID_list = tool_manager.read_bozhi_cveids()
    # CVEID_list = CVEID_list[:4709]

    CVE_patch_pairs = {}
    CVEID_not_in_our_db = []
    CVEID_not_in_GT = []
    # 提取CVE对应的patch进行对比
    for CVEID in CVEID_list:
        logger.info(CVEID + ',' + CVEID_list.index(CVEID).__str__() + '/' + len(CVEID_list).__str__())
        PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH = config.PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH % CVEID
        # todo, tocheck!!!! 这是没有运行出结果啊，不应该直接归结为CVEID_not_in_our_db
        if not file_processing.pathExist(path=PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH):
            CVEID_not_in_our_db.append(CVEID)
            print('pathExist not: ', CVEID)
            continue  # our db no patch
        # localized_res = localized_CVE_patches[CVEID]
        localized_res = generate_localized_CVE_patch_result(CVEID)[CVEID]
        if not localized_res: CVEID_not_in_our_db.append(CVEID);continue;  # our db no patch
        localized_res_in_url = [ele.formatted_url for ele in localized_res]
        localized_res_in_url = list(set(localized_res_in_url))
        CVE_patch_pairs[CVEID] = localized_res_in_url

    print('CVEID_list: ', len(CVEID_list))
    print('CVE_patch_pairs.keys()', len(CVE_patch_pairs.keys()))
    json_processing.write(json_content=CVE_patch_pairs,
                          path='CVE_patch_pairs_3000+.json')

    import random
    CVE_patch_pairs = json_processing.read(path='CVE_patch_pairs_3000+.json')
    CVE_patch_pairs_keys_list = list(CVE_patch_pairs.keys())
    disordered_CVE_patch_pairs_keys_list = random.sample(CVE_patch_pairs_keys_list, len(CVE_patch_pairs_keys_list))
    json_processing.write(json_content=disordered_CVE_patch_pairs_keys_list,
                          path='disordered_CVE_patch_pairs_3000+_CVEID_list.json')

def unify_patch_format_for_evalution(patches_to_unify: list):
    """统一patch格式，便于对比"""
    unified_patches = []
    for ref in patches_to_unify:
        ref = urllib.parse.unquote(ref)  # url解码, ref = ref.replace('%2F','/')
        # 统一git commit
        # "https://gitbox.apache.org/repos/asf?p=commons-compress.git;a=commitdiff;h=4ad5d80a6272e007f64a6ac66829ca189a8093b9",
        # "https://git.moodle.org/gw?p=moodle.git&a=search&h=HEAD&st=commit&s=MDL-39678"
        # "https://git.moodle.org/gw?p=moodle.git;a=commit;h=6fadab94f0b5790b236aa96012c47e1804ef5858"
        # "https://github.com/apache/commons-compress/commit/4ad5d80a6272e007f64a6ac66829ca189a8093b9"
        # "https://github.com/scala/scala/pull/6108/commits/b64ad85d1cfdfff29d0836a66736d6d2b0830c0e"
        # http://git-wip-us.apache.org/repos/asf/lucene-solr/commit/2f5ecbcf
        if ('/commit/' in ref and '/github.com/' in ref) or ('/commits/' in ref and 'api.github.com/' in ref) \
                or ('/commits/' in ref and '/github.com/' in ref) \
                or (';a=commit' in ref) or ('st=commit' in ref) \
                or ('/commit/' in ref and 'git.' in ref) \
                or ('/commit/' in ref and 'git-' in ref) \
                or ('/commit' in ref and '.git' in ref and 'id=' in ref) \
                or ('/commit' in ref and 'git.' in ref and 'id=' in ref) \
                or ('/commit/' in ref and 'gitlab' in ref) \
                or ('commit' in ref and re_util.extract_commitid_in_commit_url(url=ref)) \
                or ('/git' in ref and re_util.extract_commitid_in_commit_url(url=ref)):
            if '/commit/' in ref and '/github.com/' in ref:
                # https://github.com/wsargent/playframework/commit/35905f45381de788743ba9546e5eee69fe1c332f#commitcomment-5505084",
                # https://github.com/lurcher/unixODBC/commit/45ef78e037f578b15fc58938a3a3251655e71d6f#diff-d52750c7ba4e594410438569d8e2963aL24
                # commitId = ref.split('commit/')[-1].split('#')[0]
                commitId = re_util.extract_commitid_in_commit_url(url=ref)
            elif '/commits/' in ref and 'api.github.com/' in ref:
                # https://api.github.com/repos/NixOS/nixpkgs/commits/51b79c365ea8b0303c076997bf396b628518a480
                commitId = ref.split('/commits/')[-1].split('#')[0]
            elif '/commits/' in ref and '/github.com/' in ref:
                # https://github.com/scala/scala/pull/6108/commits/b64ad85d1cfdfff29d0836a66736d6d2b0830c0e
                commitId = ref.split('/commits/')[-1].split('#')[0]
            elif ';h=' in ref:
                commitId = ref.split(';h=')[1]
            elif '&s=' in ref:
                commitId = ref.split('&s=')[1]
            elif ('/commit/' in ref and 'git.' in ref):
                # https://git.openstack.org/openstack/neutron/commit/54aa6e81cb17b33ce4d5d469cc11dec2869c762d.diff
                # https://git.openstack.org/cgit/openstack/neutron/commit/?id=54aa6e81cb17b33ce4d5d469cc11dec2869c762d
                commitId = ref.split('/commit/')[1].split('.')[0].split('=')[-1]
            elif '/commit/' in ref and 'git-' in ref:
                # http://git-wip-us.apache.org/repos/asf/lucene-solr/commit/2f5ecbcf
                commitId = ref.split('/commit/')[1].split('.')[0].split('=')[-1]
            elif ('/commit' in ref and '.git' in ref and 'id=' in ref) or (
                    '/commit' in ref and 'git.' in ref and 'id=' in ref):
                # https://anonscm.debian.org/cgit/pkg-java/jython.git/commit/?id=fa94dba
                # https://anonscm.debian.org/cgit/pkg-java/jython.git/commit?id=fa94dba
                commitId = ref.split('/commit')[1].split('.')[0].split('=')[-1]
            elif ('/commit/' in ref and 'gitlab' in ref):
                commitId = ref.split('/commit/')[1].split('.')[0].split('=')[-1]
            elif ('commit' in ref and re_util.extract_commitid_in_commit_url(url=ref)):
                commitId = re_util.extract_commitid_in_commit_url(url=ref)
            else:  # 下下策啦
                commitId = re_util.extract_commitid_in_commit_url(url=ref)
                if not commitId:
                    commitId = ref
            # 'https://github.com/javamelody/javamelody/commit/1739587'
            if '&s=' in ref:
                commitId = ref.split('&s=')[1]
            else:
                commitId = re_util.extract_commitid_in_commit_url(url=ref)
            if not commitId:  # 单独针对上述处理！
                commitId = ref.split('commit/')[-1].split('commits/')[-1].split('/')[0]
            # print(patches_to_unify)
            commitId_pre6 = commitId[:6]
            unified_ref = 'git_' + commitId_pre6
            unified_patches.append(unified_ref)
        elif 'svn' in ref and re_util.extract_commitid_in_svn_url(url=ref):
            commitId = re_util.extract_commitid_in_svn_url(url=ref)
            unified_ref = 'svn_' + commitId.strip('r')
            unified_patches.append(unified_ref)
        elif re_util.extract_commitid_in_commit_url(url=ref):
            commitId_pre6 = re_util.extract_commitid_in_commit_url(url=ref)[:6]
            unified_ref = 'git_' + commitId_pre6
            unified_patches.append(unified_ref)
        else:
            unified_patches.append(ref)
    return sorted(list(set(unified_patches)))

def evaluate(predict_result, ground_truth):
    """
    :param predict_result: 是一串 patch nodes
    :param ground_truth:
    :return:
    """
    result_item = {'detail_metrics': {'tp': 0, 'fp': 0, 'tn': 0, 'fn4gt': 0, 'fn': 0}, 'fp_list': None, 'fn_list': None,
                   'precision': 0,
                   'recall': 0}
    evaluate_result = {'all branch patches': result_item, 'max branch recall': result_item,
                       'mean branch recall': result_item}
    if len(predict_result) == 0:
        gt_flag = [0] * len(ground_truth['all_branches'])
        fn4gt = gt_flag.count(0)
        evaluate_result['all branch patches']['detail_metrics']['fn4gt'] = fn4gt
        return evaluate_result

    # 需要做列表，插flag，以标记PR or GT；便于统计tp fp tn fn； PR就是纯list， GT就得按照branch做成字典了
    # 1. 不区分branch，全量验证GT； 考虑等价，统计tp fp tn fn，计算 precision、recall、f1-score
    # 预处理，准备工作
    pr_flag = [0] * len(predict_result)
    gt_flag = [0] * len(ground_truth['all_branches'])
    # 格式化信息，同一规范，便于compare
    # print([ ele[2]+ele[3]+ele[4]  for ele in ground_truth['all_branches'] ])
    formal_gt_info = unify_patch_format_for_evalution(
        [ele[2] + ele[3] + ele[4] for ele in ground_truth['all_branches']])
    formal_gt_equivalent_info = {}  # {formal patch:[equivalent patches]}
    for ele in ground_truth['all_branches']:
        ele_patch = ele[2] + ele[3] + ele[4]
        formal_ele_patch = unify_patch_format_for_evalution([ele_patch])[0]

        equivalent = ele[5]
        formal_gt_equivalent_info[formal_ele_patch] = []
        if equivalent:
            patch1 = equivalent.split('==')[0]
            patch2 = equivalent.split('==')[1]
            # 因为，commitID总是提取不对，前6位都是数字的话，就很难顶。
            if formal_ele_patch.split('git_')[-1] in patch1 and '+' not in patch1:  # 说明右侧为等价patch
                if '+' in patch2:  # 右侧为一对多
                    patches = patch2.split('+')
                    for ele_patch in patches:
                        if 'git' in ele_patch:
                            formal_ele_patch_ = unify_patch_format_for_evalution([ele_patch])[0]
                            formal_gt_equivalent_info[formal_ele_patch].append(formal_ele_patch_[:10])  # 格式化
                            # formal_gt_equivalent_info[formal_ele_patch].append( ele_patch[:10] ) # 格式化
                        else:
                            formal_gt_equivalent_info[formal_ele_patch].append(ele_patch)
                else:  # 右侧为一对一
                    if 'git' in patch2:
                        formal_patch2 = unify_patch_format_for_evalution([patch2])[0]
                        formal_gt_equivalent_info[formal_ele_patch].append(formal_patch2[:10])  # 格式化
                        # formal_gt_equivalent_info[formal_ele_patch].append(patch2[:10])  # 格式化
                    else:
                        formal_gt_equivalent_info[formal_ele_patch].append(patch2)
            elif formal_ele_patch.split('git_')[-1] in patch2 and '+' not in patch2:  # 说明左侧为等价patch
                if '+' in patch1:  # 右侧为一对多
                    patches = patch1.split('+')
                    for ele_patch in patches:
                        if 'git' in ele_patch:
                            formal_ele_patch_ = unify_patch_format_for_evalution([ele_patch])[0]
                            formal_gt_equivalent_info[formal_ele_patch].append(formal_ele_patch_[:10])  # 格式化
                            # formal_gt_equivalent_info[formal_ele_patch].append(ele_patch[:10])  # 格式化
                        else:
                            formal_gt_equivalent_info[formal_ele_patch].append(ele_patch)
                else:  # 右侧为一对一
                    if 'git' in patch1:
                        formal_patch1 = unify_patch_format_for_evalution([patch1])[0]
                        formal_gt_equivalent_info[formal_ele_patch].append(formal_patch1[:10])  # 格式化
                        # formal_gt_equivalent_info[formal_ele_patch].append(patch1[:10])  # 格式化
                    else:
                        formal_gt_equivalent_info[formal_ele_patch].append(patch1)

    for node_index in range(len(predict_result)):
        node = predict_result[node_index]
        category_in_type = node.category_in_type
        formal_patch_info = unify_patch_format_for_evalution([node.formatted_url])[0]
        if formal_patch_info in formal_gt_info:
            pr_flag[node_index] = 1
            # gt_flag
            gt_index = formal_gt_info.index(formal_patch_info)
            gt_flag[gt_index] = 1

    # 处理：等价项； 循环迭代，直至没有项更新
    # todo, to test
    flag_update = True  # 初始化为T
    while flag_update:
        flag_update = False  # 进入运行后，改为 False
        for gt_ele in formal_gt_info:
            gt_ele_index = formal_gt_info.index(gt_ele)
            # 此gt_ele已hit， 去hit equivalent patch
            if gt_flag[gt_ele_index] == 1 and formal_gt_equivalent_info[gt_ele]:
                for equivalent_patch_ele in formal_gt_equivalent_info[gt_ele]:
                    # print( equivalent_patch_ele,formal_gt_equivalent_info , formal_gt_info)
                    equivalent_patch_ele_index = formal_gt_info.index(equivalent_patch_ele)
                    if gt_flag[equivalent_patch_ele_index] == 0:  # hit new patch
                        gt_flag[equivalent_patch_ele_index] = 1
                        flag_update = True
            # 此gt_ele未hit， 查看equivalent patch是否已hit
            if gt_flag[gt_ele_index] == 0 and formal_gt_equivalent_info[gt_ele]:
                equivalent_patches_not_hit = False
                for equivalent_patch_ele in formal_gt_equivalent_info[gt_ele]:
                    # print(equivalent_patch_ele, formal_gt_equivalent_info, formal_gt_info)
                    equivalent_patch_ele_index = formal_gt_info.index(equivalent_patch_ele)
                    if gt_flag[equivalent_patch_ele_index] == 0:  # 存在未hit的equivalent_patch
                        equivalent_patches_not_hit = True
                        break
                if not equivalent_patches_not_hit:
                    gt_flag[gt_ele_index] = 1  # hit new patch
                    flag_update = True
    tp = pr_flag.count(1)
    fp = pr_flag.count(0)
    tn = 0
    # tp4gt = gt_flag.count(1)
    fn4gt = gt_flag.count(0)
    # todo,to discuss
    precision = tp / (tp + fp)
    recall = tp / (tp + fn4gt)
    if precision + recall == 0:
        f1_score = 0
    else:
        f1_score = 2 * precision * recall / (precision + recall)
    # print(  gt_flag, formal_gt_info)
    tp_list = [predict_result[ele_index].formatted_url for ele_index in range(len(pr_flag)) if pr_flag[ele_index] == 1]
    fp_list = [predict_result[ele_index].formatted_url for ele_index in range(len(pr_flag)) if pr_flag[ele_index] == 0]
    # print(  gt_flag,formal_gt_info   )
    fn_list = [formal_gt_info[ele_index] for ele_index in range(len(gt_flag)) if gt_flag[ele_index] == 0]
    evaluate_result['all branch patches'] = {
        'precision': precision, 'recall': recall, 'f1_score': f1_score,
        'detail_metrics': {'tp': tp, 'fp': fp, 'tn': tn, 'fn4gt': fn4gt},
        'tp_list': tp_list, 'fp_list': fp_list, 'fn_list': fn_list, }

    # todo, 2.1 针对不同branch，进行验证；取 单个branch的max_recall to discuss
    # todo, 2.2 针对不同branch，进行验证；取 所有branch的mean_recall to discuss
    return evaluate_result

def main_evaluate_ours():
    load_ground_truth()
    localized_CVE_patches = {}  # 全局CVE-fix pairs
    evaluate_result = {}

    # CVEID_list = json_processing.read(path=config.PATCH_LOCALIZATION_EXPERIMENTAL_CVEIDS_WITH_PATCH) + json_processing.read(path=config.PATCH_LOCALIZATION_EXPERIMENTAL_CVEIDS_WITHOUT_PATCH)
    # GT_CVEID_list = json_processing.read(path=config.PATCH_LOCALIZATION_EXPERIMENTAL_CVEIDS_WITH_PATCH_EXCLUDING_LY)
    # CVEID_list = GT_CVEID_list  # 目前只有前500的数据
    # GT_classification_info = {'single_PG': [], 'multiple_PGs_but_single_branch': [], 'multiple_PGs_and_branches': []}

    """
    # 用多进程并发，统一算一下localized_CVE_patches
    res = []
    pool = multiprocessing.Pool(processes=10)
    # 提取CVE对应的patch进行对比
    for CVEID in CVEID_list:
        print(CVEID, CVEID_list.index(CVEID))
        if CVEID not in formal_GT: continue
        PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH = '/mydisk/fudan_se_cam/CongyingXu/gitrepo/VulnerabilityAnalysis/output/patch_localization/cve_patch_objs/%s' % CVEID
        if not file_processing.pathExist(path=PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH): continue  # our db no patch
        res.append( pool.apply_async(generate_localized_CVE_patch_result, (CVEID,))  )# 维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去
    pool.close()
    pool.join()  # 调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束
    print("Sub-process(es) done.")
    for ele in res:
        localized_CVE_patches.update(ele)
    """
    global_precision_sum = 0
    global_recall_sum = 0
    global_CVEID_not_in_our_db = []
    global_CVEID_list = []
    # CVEID_not_todo_list = ['CVE-2010-5312','CVE-2013-5123','CVE-2014-0160','CVE-2014-0195','CVE-2014-0221','CVE-2014-1830','CVE-2014-3508','CVE-2014-3506']# 由于graph过大（肯定是有问题），导致耗时过长，无法有效debug；先将其pass掉
    # 应该可以通过删除冗余patch节点，进行优化
    # CVEID_not_todo_list = [ 'CVE-2010-5312','CVE-2014-0160','CVE-2014-3505','CVE-2014-3506','CVE-2014-3508','CVE-2014-3510','CVE-2014-3513','CVE-2014-3572','CVE-2014-4611','CVE-2014-9130','CVE-2015-0205','CVE-2015-0288',
    #                         'CVE-2013-5123', 'CVE-2019-1002101' ] # 改良算法后，现在没有时间影响了
    # 运行起来，时间太长了，便于迭代，先暂时屏蔽掉s
    CVEID_with_running_error = []
    print('---------------------------- Graph-based Tool')
    for cve_fix_type in GT_classification_info.keys():
        CVEID_not_in_our_db = []
        CVEID_not_in_GT = []
        CVEID_list = GT_classification_info[cve_fix_type]
        evaluate_result[cve_fix_type] = {'all branch patches': {}, 'max branch recall': {}, 'mean branch recall': {}}
        # 提取CVE对应的patch进行对比
        for CVEID in CVEID_list:
            # import random
            # random.shuffle( CVEID_list ) # 做一个乱序处理，防止其疯狂request同一个域名，导致被封！
            # print(CVEID, CVEID_list.index(CVEID), len(CVEID_list))
            # for debug
            # print(CVEID)
            if CVEID in CVEID_not_todo_list: logger.info(
                'Pass:' + CVEID + ' ' + CVEID_list.index(CVEID).__str__()); continue;
            # logger.info( CVEID +' '+ CVEID_list.index( CVEID ).__str__() )
            if CVEID not in formal_GT: CVEID_not_in_GT.append(CVEID);continue;
            PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH = '/mydisk/fudan_se_cam/CongyingXu/gitrepo/VulnerabilityAnalysis/output/patch_localization/cve_patch_objs/%s' % CVEID
            # todo, tocheck!!!! 这是没有运行出结果啊，不应该直接归结为CVEID_not_in_our_db
            if not file_processing.pathExist(path=PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH):
                print(CVEID)
                CVEID_with_running_error.append(CVEID)
                CVEID_not_in_our_db.append(CVEID)
                continue  # our db no patch
            # localized_res = localized_CVE_patches[CVEID]
            localized_res = generate_localized_CVE_patch_result(CVEID)[CVEID]
            if not localized_res: CVEID_not_in_our_db.append(CVEID);continue;  # our db no patch
            evaluate_res = evaluate(predict_result=localized_res, ground_truth=formal_GT[CVEID])
            evaluate_result[cve_fix_type]['all branch patches'][CVEID] = evaluate_res['all branch patches']
            # print(evaluate_res);break;
            # 记录单个CVE的evaluate——res， 最后算个平均

        # 处理结果
        precision_sum = 0
        recall_sum = 0
        for CVEID in CVEID_list:
            if CVEID in CVEID_not_in_GT or CVEID in CVEID_not_in_our_db or CVEID in CVEID_not_todo_list: continue
            precision_sum += evaluate_result[cve_fix_type]['all branch patches'][CVEID]['precision']
            recall_sum += evaluate_result[cve_fix_type]['all branch patches'][CVEID]['recall']
        evaluate_result[cve_fix_type]['CVEID_not_in_our_db'] = CVEID_not_in_our_db
        evaluate_result[cve_fix_type]['all branch patches']['total'] = {}
        evaluate_result[cve_fix_type]['all branch patches']['total']['precision'] = precision_sum / (
                    len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1)
        evaluate_result[cve_fix_type]['all branch patches']['total']['recall'] = recall_sum / (
                    len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1)
        # json_processing.write( json_content=evaluate_result, path='evaluate_result_cve_fix_type_with_EXCN20418.json' )
        return_ration = (len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1) / len(CVEID_list)
        print('-------', cve_fix_type + ':',
              (len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1).__str__() + '/' + len(
                  CVEID_list).__str__(), f'({return_ration.__str__()[:5]})')
        print(evaluate_result[cve_fix_type]['all branch patches']['total'])
        print('CVEID_not_in_our_db: ', len(CVEID_not_in_our_db))
        # print('CVEID_not_in_GT: ', len(CVEID_not_in_GT))
        # 数据收集
        global_precision_sum += precision_sum
        global_recall_sum += recall_sum
        global_CVEID_not_in_our_db.extend(CVEID_not_in_our_db)
        global_CVEID_list.extend(CVEID_list)
    print('+++++++ Total:', global_CVEID_list.__len__().__str__())
    print('Mean precision:',
          global_precision_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()))
    print('Mean recall:', global_recall_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()))
    print('not-found ratio:', global_CVEID_not_in_our_db.__len__() / global_CVEID_list.__len__())

    json_processing.write(json_content=CVEID_with_running_error, path='CVEID_with_running_error.json')
    print('len(CVEID_with_running_error)', len(CVEID_with_running_error))
    print(CVEID_with_running_error)

def main_evaluate_vulnerabilityDB():
    """
    1. 读取vulnerabilityDB数据
    2. 将url全部转为patch node
    3. compare, 进行验证
    :return:
    """
    # GT_CVEID_list =  json_processing.read( path=config.PATCH_LOCALIZATION_EXPERIMENTAL_CVEIDS_WITH_PATCH_EXCLUDING_LY )
    # CVEID_list = GT_CVEID_list #目前只有前500的数据
    original_formal_GT, original_GT_classification_info = load_ground_truth()
    new_formal_GT, new_GT_classification_info = load_ground_truth_with_new_classification()
    global formal_GT, GT_classification_info
    formal_GT = original_formal_GT
    GT_classification_info = new_GT_classification_info
    # load_ground_truth()

    # our_pre_tool_patch_result_raw = json_processing.read(config.PATCH_LOCALIZATION_OUR_PRE_TOOL_PATCH_RESULT)
    # our_pre_tool_patch_result_all_patches = {}
    # our_pre_tool_patch_result_patches_by_voting = {}
    # for ele in our_pre_tool_patch_result_raw:
    #     CVEID = ele['CVEID']
    #     # our_pre_tool_patch_result_all_patches[CVEID] = ele['all_patches']
    #     # our_pre_tool_patch_result_patches_by_voting[CVEID] = ele['all_patches_by_voting']
    #     our_pre_tool_patch_result_all_patches[CVEID] = confirm_patch.filter_security_doc_commits( confirm_patch.filter_security_test_commits( ele['all_patches'] ) )
    #     our_pre_tool_patch_result_patches_by_voting[CVEID] = confirm_patch.filter_security_doc_commits( confirm_patch.filter_security_test_commits( ele['all_patches_by_voting'] ) )

    VeracodeDB_patch_ground_truth_path = config.DR010_VERACODEDB_PATCH_GROUND_TRUTH_PATH
    SnykDB_patch_ground_truth_path = config.DR010_SNYKDB_PATCH_GROUND_TRUTH_PATH
    DR010_Gitlab_PATCH_GROUND_TRUTH_PATH = config.DR010_PATCH_GROUND_TRUTH_DIR + 'Gitlab_patch_ground_truth.json'
    VeracodeDB_patch_ground_truth = json_processing.read(VeracodeDB_patch_ground_truth_path)
    SnykDB_patch_ground_truth = json_processing.read(SnykDB_patch_ground_truth_path)
    DR010_Gitlab_PATCH_GROUND_TRUTH = json_processing.read(DR010_Gitlab_PATCH_GROUND_TRUTH_PATH)
    vulnerability_dbs = {
        'Veracode': VeracodeDB_patch_ground_truth,
        'Snyk': SnykDB_patch_ground_truth,
        # 'Gitlab': DR010_Gitlab_PATCH_GROUND_TRUTH,
        # 'Pattern-based Tool(all_patches)':our_pre_tool_patch_result_all_patches,
        # 'Pattern-based Tool(patchesby_voting)':our_pre_tool_patch_result_patches_by_voting
    }

    # VeracodeDB_patch_ground_truth
    for vuldb in vulnerability_dbs.keys():
        print('----------------------------', vuldb)
        evaluate_result = {}
        global_precision_sum = 0
        global_recall_sum = 0
        global_f1_score_sum = 0
        global_CVEID_not_in_our_db = []
        global_CVEID_list = []
        for cve_fix_type in GT_classification_info.keys():
            CVEID_not_in_vuldb = []
            CVEID_not_in_GT = []
            CVEID_list = GT_classification_info[cve_fix_type]
            evaluate_result[cve_fix_type] = {'all branch patches': {}, 'max branch recall': {},
                                             'mean branch recall': {}}
            # CVEID_not_todo_list = ['CVE-2014-9970']
            print('-----', cve_fix_type, len(CVEID_list))
            for CVEID in CVEID_list:
                # print(CVEID)
                if CVEID in CVEID_not_todo_list: continue
                # CVEID='CVE-2014-9970'
                if CVEID not in formal_GT: CVEID_not_in_GT.append(CVEID);continue;
                if CVEID not in vulnerability_dbs[vuldb] or len(
                    vulnerability_dbs[vuldb][CVEID]) == 0: CVEID_not_in_vuldb.append(CVEID);continue;
                # 提取每一个CVE： patch url，并转成patch node
                patches = vulnerability_dbs[vuldb][CVEID]
                patches_in_node = [cls_node.Node(node_content_type='url', node_content=patch_ele) for patch_ele in
                                   patches]  # 将patch url转换成
                evaluate_res = evaluate(predict_result=patches_in_node, ground_truth=formal_GT[CVEID])
                evaluate_result[cve_fix_type]['all branch patches'][CVEID] = evaluate_res['all branch patches']
                # 记录单个CVE的evaluate——res， 最后算个平均

            # 处理结果
            precision_sum = 0
            recall_sum = 0
            f1_score_sum = 0
            for CVEID in CVEID_list:
                if CVEID in CVEID_not_in_vuldb or CVEID in CVEID_not_in_GT or CVEID in CVEID_not_todo_list: continue
                precision_sum += evaluate_result[cve_fix_type]['all branch patches'][CVEID]['precision']
                recall_sum += evaluate_result[cve_fix_type]['all branch patches'][CVEID]['recall']
                f1_score_sum += evaluate_result[cve_fix_type]['all branch patches'][CVEID]['f1_score']
            evaluate_result[cve_fix_type]['all branch patches']['total'] = {}
            evaluate_result[cve_fix_type]['all branch patches']['total']['precision'] = precision_sum / (
                        len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1)
            evaluate_result[cve_fix_type]['all branch patches']['total']['recall'] = recall_sum / (
                        len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1)
            evaluate_result[cve_fix_type]['all branch patches']['total']['f1_score'] = f1_score_sum / (
                    len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1)
            json_processing.write(json_content=evaluate_result, path=vuldb + '_evaluate_result.json')
            print(evaluate_result[cve_fix_type]['all branch patches']['total'])
            print('covered_CVE: ', len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1)
            print('CVEID_not_in_vuldb: ', len(CVEID_not_in_vuldb) ,len(CVEID_list), len(CVEID_not_in_vuldb)/len(CVEID_list) )
            print('CVEID_not_in_GT: ', len(CVEID_not_in_GT))
            # 数据收集
            global_precision_sum += precision_sum
            global_recall_sum += recall_sum
            global_f1_score_sum += f1_score_sum
            global_CVEID_not_in_our_db.extend(CVEID_not_in_vuldb)
            global_CVEID_list.extend(CVEID_list)
        print('+++++++ Total:', global_CVEID_list.__len__().__str__())
        print('Mean precision:',
              global_precision_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()))
        print('Mean recall:', global_recall_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()))
        print('Mean f1_score:',
              global_f1_score_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()))
        print('not-found ratio:', global_CVEID_not_in_our_db.__len__(),global_CVEID_list.__len__() ,global_CVEID_not_in_our_db.__len__() / global_CVEID_list.__len__())
        print('covered_CVE: ',  global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__())

def main_evaluate_with_rules(rules, formal_GT, GT_classification_info, output_path=None, predicted_result=None):
    """输入rules，基于rules提取图中内容； 并进行验证！"""
    return_data = {}

    # rules = {'src': ['all'], 'priority': 'CN', 'Extension': 30, 'searched_entities': ['all'],
    #          'patch_type': ['git_commit', 'svn'], 'patch_content': ['only_code_change',
    #                                                                 'cutoff=2']}  # valid_patch_url ,'only_code_change', 'patch_date', 'only_target_CPEs',
    # res = evaluate.generate_localized_CVE_patch_result_with_rules(CVEID=CVEID, rules=rules)
    localized_CVE_patches = {}  # 全局CVE-fix pairs
    evaluate_result = {}
    global_precision_sum = 0
    global_recall_sum = 0
    global_f1_score_sum = 0
    global_CVEID_not_in_our_db = []
    global_CVEID_list = []
    CVEID_with_running_error = []
    print('---------------------------- Graph-based Tool')
    for cve_fix_type in GT_classification_info.keys():
        CVEID_not_in_our_db = []
        CVEID_not_in_GT = []
        CVEID_list = GT_classification_info[cve_fix_type]
        evaluate_result[cve_fix_type] = {'all branch patches': {}, 'max branch recall': {}, 'mean branch recall': {}}
        # 提取CVE对应的patch进行对比
        for CVEID in CVEID_list:
            # print(CVEID)
            if CVEID not in formal_GT: CVEID_not_in_GT.append(CVEID);continue;
            PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH = '/mydisk/fudan_se_cam/CongyingXu/gitrepo/VulnerabilityAnalysis/output/patch_localization/cve_patch_objs/%s' % CVEID
            # todo, tocheck!!!! 这是没有运行出结果啊，不应该直接归结为CVEID_not_in_our_db
            if not file_processing.pathExist(path=PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH):
                print(CVEID)
                CVEID_with_running_error.append(CVEID)
                CVEID_not_in_our_db.append(CVEID)
                continue  # our db no patch
            if predicted_result:
                # 读取文件
                localized_patches_5000_100_path = '/mydisk/fudan_se_cam/CongyingXu/mirror/VulnerabilityAnalysis/vulnerability_analysis/patch_localization/script/CVE_patch_pairs_5000+.json'
                localized_patches_3000_100_path = '/mydisk/fudan_se_cam/CongyingXu/mirror/VulnerabilityAnalysis/vulnerability_analysis/patch_localization/script/CVE_patch_pairs_3000+.json'
                localized_patches_5000_100 = json_processing.read( path=localized_patches_5000_100_path )
                localized_patches_3000_100 = json_processing.read(path=localized_patches_3000_100_path)
                # 提取信息
                if CVEID in localized_patches_5000_100:
                    patches = localized_patches_5000_100[CVEID]
                elif CVEID in localized_patches_3000_100:
                    patches = localized_patches_3000_100[CVEID]
                patches_in_node = [cls_node.Node(node_content_type='url', node_content=patch_ele) for patch_ele in patches]  # 将patch url转换成
                localized_res = patches_in_node
            else:
                localized_res = generate_localized_CVE_patch_result_with_rules(CVEID=CVEID, rules=rules)[CVEID]
            if not localized_res: CVEID_not_in_our_db.append(CVEID);continue;  # our db no patch
            evaluate_res = evaluate(predict_result=localized_res, ground_truth=formal_GT[CVEID])
            evaluate_result[cve_fix_type]['all branch patches'][CVEID] = evaluate_res['all branch patches']
        # 处理结果
        precision_sum = 0
        recall_sum = 0
        f1_score_sum = 0
        for CVEID in CVEID_list:
            if CVEID in CVEID_not_in_GT or CVEID in CVEID_not_in_our_db or CVEID in CVEID_not_todo_list: continue
            precision_sum += evaluate_result[cve_fix_type]['all branch patches'][CVEID]['precision']
            recall_sum += evaluate_result[cve_fix_type]['all branch patches'][CVEID]['recall']
            f1_score_sum += evaluate_result[cve_fix_type]['all branch patches'][CVEID]['f1_score']
        evaluate_result[cve_fix_type]['CVEID_not_in_our_db'] = CVEID_not_in_our_db
        evaluate_result[cve_fix_type]['all branch patches']['total'] = {}
        evaluate_result[cve_fix_type]['all branch patches']['total']['precision'] = precision_sum / (
                    len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1)
        evaluate_result[cve_fix_type]['all branch patches']['total']['recall'] = recall_sum / (
                    len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1)
        evaluate_result[cve_fix_type]['all branch patches']['total']['f1_score'] = f1_score_sum / (
                len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1)

        if output_path:
            json_processing.write(json_content=evaluate_result, path=output_path)
        return_ration = (len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1) / len(
            CVEID_list)  # -1的原因是，有一个toal字段
        print('-------', cve_fix_type + ':',
              (len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1).__str__() + '/' + len(
                  CVEID_list).__str__(), f'({return_ration.__str__()[:5]})')
        print(evaluate_result[cve_fix_type]['all branch patches']['total'])
        print('CVEID_not_in_our_db: ', len(CVEID_not_in_our_db))
        # print('CVEID_not_in_GT: ', len(CVEID_not_in_GT))
        return_data[cve_fix_type] = evaluate_result[cve_fix_type]['all branch patches']['total']
        return_data[cve_fix_type]['found_ratio'] = (len(
            evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1).__str__() + '/' + len(
            CVEID_list).__str__() + '=' + f'({return_ration.__str__()[:5]})'
        # 数据收集
        global_precision_sum += precision_sum
        global_recall_sum += recall_sum
        global_f1_score_sum += f1_score_sum
        global_CVEID_not_in_our_db.extend(CVEID_not_in_our_db)
        global_CVEID_list.extend(CVEID_list)
    print('+++++++ Total:', global_CVEID_list.__len__().__str__())
    print('Mean precision:',
          global_precision_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()))
    print('Mean recall:', global_recall_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()))
    print('Mean f1_score:', global_f1_score_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()))
    print('not-found ratio:', global_CVEID_not_in_our_db.__len__() / global_CVEID_list.__len__())

    # json_processing.write( json_content=CVEID_with_running_error , path='CVEID_with_running_error.json' )
    print('len(CVEID_with_running_error)', len(CVEID_with_running_error))
    print(CVEID_with_running_error)

    return_data['Total'] = {
        'Mean precision': global_precision_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()),
        'Mean recall': global_recall_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()),
        'Mean f1_score': global_f1_score_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()),
        'not-found ratio': global_CVEID_not_in_our_db.__len__() / global_CVEID_list.__len__(),
        'num': global_CVEID_list.__len__()
        }
    return return_data

def main_evaluate_with_rules_nf2recall(rules, formal_GT, GT_classification_info, output_path=None):
    """
    输入rules，基于rules提取图中内容； 并进行验证！
    nf2recall:是指将not found算为 recall为0，不参与precison计算！
    """
    return_data = {}

    # rules = {'src': ['all'], 'priority': 'CN', 'Extension': 30, 'searched_entities': ['all'],
    #          'patch_type': ['git_commit', 'svn'], 'patch_content': ['only_code_change',
    #                                                                 'cutoff=2']}  # valid_patch_url ,'only_code_change', 'patch_date', 'only_target_CPEs',
    # res = evaluate.generate_localized_CVE_patch_result_with_rules(CVEID=CVEID, rules=rules)
    localized_CVE_patches = {}  # 全局CVE-fix pairs
    evaluate_result = {}
    global_precision_sum = 0
    global_recall_sum = 0
    global_f1_score_sum = 0
    global_CVEID_not_in_our_db = []
    global_CVEID_list = []
    CVEID_with_running_error = []
    # in_our_db = []
    print('---------------------------- Graph-based Tool')
    for cve_fix_type in GT_classification_info.keys():
        CVEID_not_in_our_db = []
        CVEID_not_in_GT = []
        CVEID_list = GT_classification_info[cve_fix_type]
        evaluate_result[cve_fix_type] = {'all branch patches': {}, 'max branch recall': {}, 'mean branch recall': {}}
        # 提取CVE对应的patch进行对比
        for CVEID in CVEID_list:
            # print(CVEID)
            if CVEID not in formal_GT: CVEID_not_in_GT.append(CVEID);continue;
            PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH = '/mydisk/fudan_se_cam/CongyingXu/gitrepo/VulnerabilityAnalysis/output/patch_localization/cve_patch_objs/%s' % CVEID
            # todo, tocheck!!!! 这是没有运行出结果啊，不应该直接归结为CVEID_not_in_our_db
            if not file_processing.pathExist(path=PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH):
                print(CVEID)
                CVEID_with_running_error.append(CVEID)
                CVEID_not_in_our_db.append(CVEID)
                continue  # our db no patch
            localized_res = generate_localized_CVE_patch_result_with_rules(CVEID=CVEID, rules=rules)[CVEID]
            if not localized_res: CVEID_not_in_our_db.append(CVEID);continue;  # our db no patch
            evaluate_res = evaluate(predict_result=localized_res, ground_truth=formal_GT[CVEID])
            evaluate_result[cve_fix_type]['all branch patches'][CVEID] = evaluate_res['all branch patches']
        # 处理结果
        precision_sum = 0
        recall_sum = 0
        # f1_score_sum = 0
        for CVEID in CVEID_list:
            if CVEID in CVEID_not_in_GT or CVEID in CVEID_not_in_our_db or CVEID in CVEID_not_todo_list: continue
            precision_sum += evaluate_result[cve_fix_type]['all branch patches'][CVEID]['precision']
            recall_sum += evaluate_result[cve_fix_type]['all branch patches'][CVEID]['recall']
            # f1_score_sum += evaluate_result[cve_fix_type]['all branch patches'][CVEID]['f1_score']
        evaluate_result[cve_fix_type]['CVEID_not_in_our_db'] = CVEID_not_in_our_db
        evaluate_result[cve_fix_type]['all branch patches']['total'] = {}
        evaluate_result[cve_fix_type]['all branch patches']['total']['precision'] = precision_sum / (
                    len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1)
        evaluate_result[cve_fix_type]['all branch patches']['total']['recall'] = recall_sum / (
                    len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1 + len(CVEID_not_in_our_db))
        # evaluate_result[cve_fix_type]['all branch patches']['total']['f1_score'] = f1_score_sum / (
        #         len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1)

        if output_path:
            json_processing.write(json_content=evaluate_result, path=output_path)
        return_ration = (len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1) / len(
            CVEID_list)  # -1的原因是，有一个toal字段
        print('-------', cve_fix_type + ':',
              (len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1).__str__() + '/' + len(
                  CVEID_list).__str__(), f'({return_ration.__str__()[:5]})')
        print(evaluate_result[cve_fix_type]['all branch patches']['total'])
        print('CVEID_not_in_our_db: ', len(CVEID_not_in_our_db))
        # print('CVEID_not_in_GT: ', len(CVEID_not_in_GT))
        return_data[cve_fix_type] = evaluate_result[cve_fix_type]['all branch patches']['total']
        # return_data[cve_fix_type]['found_ratio'] = (len(
        #     evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1).__str__() + '/' + len(
        #     CVEID_list).__str__() + '=' + f'({return_ration.__str__()[:5]})'
        # 数据收集
        global_precision_sum += precision_sum
        global_recall_sum += recall_sum
        # global_f1_score_sum += f1_score_sum
        global_CVEID_not_in_our_db.extend(CVEID_not_in_our_db)
        global_CVEID_list.extend(CVEID_list)
    print('+++++++ Total:', global_CVEID_list.__len__().__str__())
    print('Mean precision:',
          global_precision_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()))
    print('Mean recall:', global_recall_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()))
    # print('Mean f1_score:', global_f1_score_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()))
    # print('not-found ratio:', global_CVEID_not_in_our_db.__len__() / global_CVEID_list.__len__())

    # json_processing.write( json_content=CVEID_with_running_error , path='CVEID_with_running_error.json' )
    print('len(CVEID_with_running_error)', len(CVEID_with_running_error))
    print(CVEID_with_running_error)

    return_data['Total'] = {
        'Mean precision': global_precision_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()),
        'Mean recall': global_recall_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()),
        # 'Mean f1_score': global_f1_score_sum / (global_CVEID_list.__len__() - global_CVEID_not_in_our_db.__len__()),
        # 'not-found ratio': global_CVEID_not_in_our_db.__len__() / global_CVEID_list.__len__(),
        'num': global_CVEID_list.__len__()
        }
    return return_data

def main_evaluate_with_rules_huizong(rules, formal_GT, GT_classification_info, output_path=None):
    """输入rules，基于rules提取图中内容； 并进行验证！"""
    return_data = {}

    # rules = {'src': ['all'], 'priority': 'CN', 'Extension': 30, 'searched_entities': ['all'],
    #          'patch_type': ['git_commit', 'svn'], 'patch_content': ['only_code_change',
    #                                                                 'cutoff=2']}  # valid_patch_url ,'only_code_change', 'patch_date', 'only_target_CPEs',
    # res = evaluate.generate_localized_CVE_patch_result_with_rules(CVEID=CVEID, rules=rules)
    localized_CVE_patches = {}  # 全局CVE-fix pairs
    evaluate_result = {}
    global_precision_sum = 0
    global_recall_sum = 0
    global_f1_score_sum = 0
    global_CVEID_not_in_our_db = []
    global_CVEID_list = []
    CVEID_with_running_error = []
    global_tp = 0
    global_fp = 0
    global_tn = 0
    global_fn4gt = 0
    print('---------------------------- Graph-based Tool')
    for cve_fix_type in GT_classification_info.keys():
        CVEID_not_in_our_db = []
        CVEID_not_in_GT = []
        CVEID_list = GT_classification_info[cve_fix_type]
        evaluate_result[cve_fix_type] = {'all branch patches': {}, 'max branch recall': {}, 'mean branch recall': {}}
        cve_fix_type_tp = 0
        cve_fix_type_fp = 0
        cve_fix_type_tn = 0
        cve_fix_type_fn4gt = 0
        # 提取CVE对应的patch进行对比
        for CVEID in CVEID_list:
            # print(CVEID)
            if CVEID not in formal_GT: CVEID_not_in_GT.append(CVEID);continue;
            PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH = '/mydisk/fudan_se_cam/CongyingXu/gitrepo/VulnerabilityAnalysis/output/patch_localization/cve_patch_objs/%s' % CVEID
            # todo, tocheck!!!! 这是没有运行出结果啊，不应该直接归结为CVEID_not_in_our_db
            if not file_processing.pathExist(path=PATCH_LOCALICATION_OUTPUT_CVE_PATCH_OBJ_PATH):
                print(CVEID)
                CVEID_with_running_error.append(CVEID)
                CVEID_not_in_our_db.append(CVEID)
                continue  # our db no patch
            localized_res = generate_localized_CVE_patch_result_with_rules(CVEID=CVEID, rules=rules)[CVEID]
            # if not localized_res: CVEID_not_in_our_db.append(CVEID);continue; # our db no patch
            evaluate_res = evaluate(predict_result=localized_res, ground_truth=formal_GT[CVEID])
            evaluate_result[cve_fix_type]['all branch patches'][CVEID] = evaluate_res['all branch patches']

            tp = evaluate_res['all branch patches']['detail_metrics']['tp']
            fp = evaluate_res['all branch patches']['detail_metrics']['fp']
            tn = evaluate_res['all branch patches']['detail_metrics']['tn']
            fn4gt = evaluate_res['all branch patches']['detail_metrics']['fn4gt']
            cve_fix_type_tp += tp
            cve_fix_type_fp += fp
            cve_fix_type_tn += tn
            cve_fix_type_fn4gt += fn4gt
            global_tp += tp
            global_fp += fp
            global_tn += tn
            global_fn4gt += fn4gt

        # 汇总一波
        precision = cve_fix_type_tp / (cve_fix_type_tp + cve_fix_type_fp)
        recall = cve_fix_type_tp / (cve_fix_type_tp + cve_fix_type_fn4gt)
        f1_score = 2 * precision * recall / (precision + recall)

        evaluate_result[cve_fix_type]['CVEID_not_in_our_db'] = CVEID_not_in_our_db
        evaluate_result[cve_fix_type]['all branch patches']['total'] = {}
        evaluate_result[cve_fix_type]['all branch patches']['total']['precision'] = precision
        evaluate_result[cve_fix_type]['all branch patches']['total']['recall'] = recall
        evaluate_result[cve_fix_type]['all branch patches']['total']['f1_score'] = f1_score

        if output_path:
            json_processing.write(json_content=evaluate_result, path=output_path)
        return_ration = (len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1) / len(
            CVEID_list)  # -1的原因是，有一个toal字段
        print('-------', cve_fix_type + ':',
              (len(evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1).__str__() + '/' + len(
                  CVEID_list).__str__(), f'({return_ration.__str__()[:5]})')
        print(evaluate_result[cve_fix_type]['all branch patches']['total'])
        print('CVEID_not_in_our_db: ', len(CVEID_not_in_our_db))
        # print('CVEID_not_in_GT: ', len(CVEID_not_in_GT))
        return_data[cve_fix_type] = evaluate_result[cve_fix_type]['all branch patches']['total']
        return_data[cve_fix_type]['found_ratio'] = (len(
            evaluate_result[cve_fix_type]['all branch patches'].keys()) - 1).__str__() + '/' + len(
            CVEID_list).__str__() + '=' + f'({return_ration.__str__()[:5]})'

    precision = global_tp / (global_tp + global_fp)
    recall = global_tp / (global_tp + global_fn4gt)
    f1_score = 2 * precision * recall / (precision + recall)
    print('+++++++ Total:', global_CVEID_list.__len__().__str__())
    print('precision:', precision)
    print('recall:', recall)
    print('f1_score:', f1_score)
    # print('not-found ratio:', global_CVEID_not_in_our_db.__len__() / global_CVEID_list.__len__())

    # json_processing.write( json_content=CVEID_with_running_error , path='CVEID_with_running_error.json' )
    print('len(CVEID_with_running_error)', len(CVEID_with_running_error))
    print(CVEID_with_running_error)

    return_data['Total'] = {'precision': precision,
                            'recall': recall,
                            'f1_score': f1_score,
                            'num': global_CVEID_list.__len__()
                            }
    return return_data

def main_evaluate_vulnerabilityDB_huizong():
    """
    1. 读取vulnerabilityDB数据
    2. 将url全部转为patch node
    3. compare, 进行验证
    :return:
    """
    # GT_CVEID_list =  json_processing.read( path=config.PATCH_LOCALIZATION_EXPERIMENTAL_CVEIDS_WITH_PATCH_EXCLUDING_LY )
    # CVEID_list = GT_CVEID_list #目前只有前500的数据
    original_formal_GT, original_GT_classification_info = load_ground_truth()
    new_formal_GT, new_GT_classification_info = load_ground_truth_with_new_classification()
    global formal_GT, GT_classification_info
    formal_GT = original_formal_GT
    GT_classification_info = new_GT_classification_info
    # load_ground_truth()

    # our_pre_tool_patch_result_raw = json_processing.read(config.PATCH_LOCALIZATION_OUR_PRE_TOOL_PATCH_RESULT)
    # our_pre_tool_patch_result_all_patches = {}
    # our_pre_tool_patch_result_patches_by_voting = {}
    # for ele in our_pre_tool_patch_result_raw:
    #     CVEID = ele['CVEID']
    #     # our_pre_tool_patch_result_all_patches[CVEID] = ele['all_patches']
    #     # our_pre_tool_patch_result_patches_by_voting[CVEID] = ele['all_patches_by_voting']
    #     our_pre_tool_patch_result_all_patches[CVEID] = confirm_patch.filter_security_doc_commits( confirm_patch.filter_security_test_commits( ele['all_patches'] ) )
    #     our_pre_tool_patch_result_patches_by_voting[CVEID] = confirm_patch.filter_security_doc_commits( confirm_patch.filter_security_test_commits( ele['all_patches_by_voting'] ) )

    VeracodeDB_patch_ground_truth_path = config.DR010_VERACODEDB_PATCH_GROUND_TRUTH_PATH
    SnykDB_patch_ground_truth_path = config.DR010_SNYKDB_PATCH_GROUND_TRUTH_PATH
    DR010_Gitlab_PATCH_GROUND_TRUTH_PATH = config.DR010_PATCH_GROUND_TRUTH_DIR + 'Gitlab_patch_ground_truth.json'
    VeracodeDB_patch_ground_truth = json_processing.read(VeracodeDB_patch_ground_truth_path)
    SnykDB_patch_ground_truth = json_processing.read(SnykDB_patch_ground_truth_path)
    DR010_Gitlab_PATCH_GROUND_TRUTH = json_processing.read(DR010_Gitlab_PATCH_GROUND_TRUTH_PATH)
    vulnerability_dbs = {
        'Veracode': VeracodeDB_patch_ground_truth,
        'Snyk': SnykDB_patch_ground_truth,
        'Gitlab': DR010_Gitlab_PATCH_GROUND_TRUTH,
        # 'Pattern-based Tool(all_patches)':our_pre_tool_patch_result_all_patches,
        # 'Pattern-based Tool(patchesby_voting)':our_pre_tool_patch_result_patches_by_voting
    }
    return_data ={}
    # VeracodeDB_patch_ground_truth
    for vuldb in vulnerability_dbs.keys():
        return_data[vuldb] = {}
        print('----------------------------', vuldb)
        evaluate_result = {}
        global_precision_sum = 0
        global_recall_sum = 0
        global_f1_score_sum = 0
        global_tp = 0
        global_fp = 0
        global_tn = 0
        global_fn4gt = 0
        global_CVEID_not_in_our_db = []
        global_CVEID_list = []
        for cve_fix_type in GT_classification_info.keys():
            CVEID_not_in_vuldb = []
            CVEID_not_in_GT = []
            CVEID_list = GT_classification_info[cve_fix_type]
            evaluate_result[cve_fix_type] = {'all branch patches': {}, 'max branch recall': {},
                                             'mean branch recall': {}}
            cve_fix_type_tp = 0
            cve_fix_type_fp = 0
            cve_fix_type_tn = 0
            cve_fix_type_fn4gt = 0
            # CVEID_not_todo_list = ['CVE-2014-9970']
            print('-----', cve_fix_type, len(CVEID_list))
            for CVEID in CVEID_list:
                # print(CVEID)
                if CVEID in CVEID_not_todo_list: continue
                # CVEID='CVE-2014-9970'
                if CVEID not in formal_GT: CVEID_not_in_GT.append(CVEID);continue;
                # if CVEID not in vulnerability_dbs[vuldb] or len(
                #     vulnerability_dbs[vuldb][CVEID]) == 0: CVEID_not_in_vuldb.append(CVEID);continue;
                # 提取每一个CVE： patch url，并转成patch node
                if CVEID in vulnerability_dbs[vuldb]:
                    patches = vulnerability_dbs[vuldb][CVEID]
                    patches_in_node = [cls_node.Node(node_content_type='url', node_content=patch_ele) for patch_ele in
                                       patches]  # 将patch url转换成
                else:
                    patches_in_node = []
                evaluate_res = evaluate(predict_result=patches_in_node, ground_truth=formal_GT[CVEID])
                evaluate_result[cve_fix_type]['all branch patches'][CVEID] = evaluate_res['all branch patches']
                # 记录单个CVE的evaluate——res， 最后算个平均

                tp = evaluate_res['all branch patches']['detail_metrics']['tp']
                fp = evaluate_res['all branch patches']['detail_metrics']['fp']
                tn = evaluate_res['all branch patches']['detail_metrics']['tn']
                fn4gt = evaluate_res['all branch patches']['detail_metrics']['fn4gt']
                cve_fix_type_tp += tp
                cve_fix_type_fp += fp
                cve_fix_type_tn += tn
                cve_fix_type_fn4gt += fn4gt
                global_tp += tp
                global_fp += fp
                global_tn += tn
                global_fn4gt += fn4gt

            # 处理结果
            # 汇总一波
            precision = cve_fix_type_tp / (cve_fix_type_tp + cve_fix_type_fp)
            recall = cve_fix_type_tp / (cve_fix_type_tp + cve_fix_type_fn4gt)
            f1_score = 2 * precision * recall / (precision + recall)
            evaluate_result[cve_fix_type]['all branch patches']['total'] = {}
            evaluate_result[cve_fix_type]['all branch patches']['total']['precision'] = precision
            evaluate_result[cve_fix_type]['all branch patches']['total']['recall'] = recall
            evaluate_result[cve_fix_type]['all branch patches']['total']['f1_score'] = f1_score
            return_data[vuldb][cve_fix_type] = evaluate_result[cve_fix_type]['all branch patches']['total']

            # json_processing.write(json_content=evaluate_result, path=vuldb + '_evaluate_result.json')
            print(evaluate_result[cve_fix_type]['all branch patches']['total'])
            print('CVEID_not_in_vuldb: ', len(CVEID_not_in_vuldb))
            print('CVEID_not_in_GT: ', len(CVEID_not_in_GT))
            global_CVEID_not_in_our_db.extend(CVEID_not_in_vuldb)
            global_CVEID_list.extend(CVEID_list)

        precision = global_tp / (global_tp + global_fp)
        recall = global_tp / (global_tp + global_fn4gt)
        f1_score = 2 * precision * recall / (precision + recall)
        print('+++++++ Total:', global_CVEID_list.__len__().__str__())
        print('precision:', precision)
        print('recall:', recall)
        print('f1_score:', f1_score)
        print('not-found ratio:', global_CVEID_not_in_our_db.__len__() / global_CVEID_list.__len__())


        return_data[vuldb]['Total'] = {'precision': precision,
                                'recall': recall,
                                'f1_score': f1_score,
                                'not-found ratio': global_CVEID_not_in_our_db.__len__() / global_CVEID_list.__len__(),
                                'num': global_CVEID_list.__len__()
                                }
    return return_data

def run_single():
    load_ground_truth()
    CVEID = 'CVE-2014-8549'  # 'CVE-2018-11798' # 'CVE-2014-4611' 'CVE-2016-6298' 'CVE-2016-10127'  'CVE-2009-0217' 'CVE-2018-1000169' 'CVE-2010-0156'
    CVE_list = ['CVE-2019-19316', 'CVE-2016-1000343', 'CVE-2013-2132', 'CVE-2017-1000246', 'CVE-2013-0248', 'CVE-2017-16016', 'CVE-2019-1010306','CVE-2014-8549', 'CVE-2019-18887', 'CVE-2018-8017']
    # CVE_list = ['CVE-2018-19361', 'CVE-2013-2254', 'CVE-2013-4249', 'CVE-2015-5147', 'CVE-2020-5247', 'CVE-2017-12160', 'CVE-2017-15809', 'CVE-2015-1838', 'CVE-2017-12867', 'CVE-2018-7560']
    # CVE_list = ['CVE-2018-11771', 'CVE-2018-3759', 'CVE-2018-1002102', 'CVE-2019-16766', 'CVE-2016-2788', 'CVE-2014-3509', 'CVE-2020-8131', 'CVE-2014-0075', 'CVE-2014-3576', 'CVE-2019-17223']
    # CVE_list = ['CVE-2017-8046', 'CVE-2019-11470', 'CVE-2018-10903', 'CVE-2011-4030', 'CVE-2012-2139', 'CVE-2019-15782', 'CVE-2016-10191', 'CVE-2017-0906']
    # CVE_list = ['CVE-2013-6044', 'CVE-2016-1000236', 'CVE-2017-16570', 'CVE-2018-7651', 'CVE-2012-5812', 'CVE-2019-12203', 'CVE-2017-16613', 'CVE-2017-11467', 'CVE-2017-7662', 'CVE-2015-9251']

    # for CVEID in CVE_list:
    cve_patches_obj = read_cve_patch_result(CVEID)
    cve_patches_obj.url_graph.visualise_graph(show_fig=True)
    # cve_patches_obj.url_graph.visualise_graph_sample(show_fig=True)
    # cve_patches_obj.url_graph.visualise_graph_sample(show_fig=False, save_fig=True, save_fig_path='CVE-2017-11428.pdf' )
    # cve_patches_obj.url_graph.get_NVD_refs_and_SG_patch_node()
    # url_graph_without_EX = cve_patches_obj.url_graph.generate_new_url_graph_without_EX()
    # patches_in_node = generate_localized_CVE_patch_result(CVEID)[CVEID]

    rules = {'src': ['all'], 'priority': 'CN', 'select_add_SG_N': True, 'Extension': 30,
             'searched_entities': ['all'], 'limited_patch_num': False, 'valid_expansion_message': True,
             'patch_type': ['git_commit', 'svn'], 'patch_content': ['only_code_change',
                                                                    'cutoff=4']}  # valid_patch_url ,'only_code_change', 'patch_date', 'only_target_CPEs',
    rules = {'src': ['all'], 'priority': 'CN', 'select_add_SG_N': True, 'Extension': 30,
             'searched_entities': ['all'], 'limited_patch_num': False, 'valid_expansion_message': True,
             'patch_type': ['git_commit', 'svn'], 'patch_content': ['only_code_change', 'cutoff=4']}
    # url_graph_without_EX = cve_patches_obj.url_graph.generate_new_url_graph_without_EX()

    # patches_in_node = generate_localized_CVE_patch_result_with_rules(CVEID,rules)[CVEID]
    # url_graph_with_rules = cve_patches_obj.url_graph.generate_new_url_graph_with_rules(rules=rules, patches_satisfying_rules = patches_in_node, pingbi_ganrao=False)

    rules['select_add_SG_N'] = None; rules['priority'] = None
    patches_in_node = generate_localized_CVE_patch_result_with_rules(CVEID, rules)[CVEID]
    url_graph_with_rules = cve_patches_obj.url_graph.generate_new_url_graph_with_rules(rules=rules,patches_satisfying_rules=patches_in_node,pingbi_ganrao=False)

    # url_graph_with_rules = cve_patches_obj.url_graph.generate_new_url_graph_with_rules()
    # url_graph_with_rules.visualise_graph_better(show_fig=False, save_fig=False, save_fig_path='ToolA_' + CVEID +'.pdf')
    url_graph_with_rules.visualise_graph(show_fig=True, save_fig=False, save_fig_path='PatFinder_' + CVEID +'.pdf')
    print(CVEID)
    print([ele.formatted_url for ele in patches_in_node])
    print([ele.formatted_id for ele in patches_in_node])
    # url_graph_without_EX.visualise_graph(show_fig=True)
    evaluate_res = evaluate(predict_result=patches_in_node, ground_truth=formal_GT[CVEID])
    # print( evaluate_res )

def check_GT():
    """校准GT
    # 1. 列出不在experimental_CVEIDs_with_VulDB_patch的CVEID
    # 2. 列出在experimental_CVEIDs_with_VulDB_patch， 但不在 GT中的CVEID
    """
    experimental_CVEIDs_with_VulDB_patch_path = config.DATA_PATH + 'patch_localization/experimental_CVEIDs_with_VulDB_patch.json'
    experimental_CVEIDs_with_VulDB_patch = json_processing.read(path=experimental_CVEIDs_with_VulDB_patch_path)
    print(len(experimental_CVEIDs_with_VulDB_patch), len(set(experimental_CVEIDs_with_VulDB_patch)))

    print('for later 500')
    load_ground_truth()
    formal_GT_CVEID_set = set(formal_GT)
    CVEID_in_GT_but_not_in_experimental_CVEIDs = set(formal_GT) - set(experimental_CVEIDs_with_VulDB_patch)
    CVEID_in_experimental_CVEIDs_but_not_in_GT = set(experimental_CVEIDs_with_VulDB_patch) - set(formal_GT)
    print('CVEID_in_GT_but_not_in_experimental_CVEIDs: ', len(CVEID_in_GT_but_not_in_experimental_CVEIDs),
          sorted(list(CVEID_in_GT_but_not_in_experimental_CVEIDs)))
    print('CVEID_in_experimental_CVEIDs_but_not_in_GT: ', len(CVEID_in_experimental_CVEIDs_but_not_in_GT),
          sorted(list(CVEID_in_experimental_CVEIDs_but_not_in_GT)))

def unify_patch_format_for_evalution_test():
    patch = 'http://code.djangoproject.com/changeset/15031'
    res = unify_patch_format_for_evalution(patches_to_unify=[patch])
    print(res == ['http://code.djangoproject.com/changeset/15031'] if res else ('fail', patch))
    patch = 'https://git.gnome.org/browse/libxml2/commit/?id=213f1fe0d76d30eaed6e5853057defc43e6df2c9'
    res = unify_patch_format_for_evalution(patches_to_unify=[patch])
    print(res == ['git_213f1f'] if res else ('fail', patch))
    patch = 'https://gitlab.gnome.org/GNOME/libxml2/commit/213f1fe0d76d30eaed6e5853057defc43e6df2c9'
    res = unify_patch_format_for_evalution(patches_to_unify=[patch])
    print(res == ['git_213f1f'] if res else ('fail', patch))
    patch = 'https://anonscm.debian.org/git/reproducible/diffoscope.git/commit?id=632a40828a54b399787c25e7fa243f732aef7e05'
    res = unify_patch_format_for_evalution(patches_to_unify=[patch])
    print(res == ['git_632a40'] if res else ('fail', patch))
    patch = 'https://salsa.debian.org/reproducible-builds/diffoscope/commit/632a40828a54b399787c25e7fa243f732aef7e05'
    res = unify_patch_format_for_evalution(patches_to_unify=[patch])
    print(res == ['git_632a40'] if res else ('fail', patch))
    patch = 'https://github.com/sparklemotion/nokogiri/commit/6d93d73498ed061dec5967d6471cd544c2b99a71'
    res = unify_patch_format_for_evalution(patches_to_unify=[patch])
    print(res == ['git_6d93d7'] if res else ('fail', patch))
    patch = 'https://anonscm.debian.org/git/reproducible/diffoscope.git/commit/?id=632a40828a54b399787c25e7fa243f732aef7e05'
    res = unify_patch_format_for_evalution(patches_to_unify=[patch])
    print(res == ['git_632a40'] if res else ('fail', patch))
    patch = 'https://git-wip-us.apache.org/repos/asf?p=qpid-proton.git;h=a05858'
    res = unify_patch_format_for_evalution(patches_to_unify=[patch])
    print(res == ['git_a05858'] if res else ('fail', patch))
    patch = 'https://svn.apache.org/viewvc?view=revision&revision=r1490149'
    res = unify_patch_format_for_evalution(patches_to_unify=[patch])
    print(res == ['svn_1490149'] if res else ('fail', patch))
    patch = 'http://svn.apache.org/viewvc?view=revision&revision=1552565'
    res = unify_patch_format_for_evalution(patches_to_unify=[patch])
    print(res == ['svn_1552565'] if res else ('fail', patch))

def generate_localized_CVE_patch_result_test():
    # test 过滤 attachment 形式的patch
    CVEID = 'CVE-2016-10345'
    res = generate_localized_CVE_patch_result(CVEID=CVEID)
    print(True if 'https://bugzilla.redhat.com/attachment.cgi?bugid=665373' not in [ele.formatted_url for ele in
                                                                                    res] else False)
    CVEID = 'CVE-2018-11788'
    res = generate_localized_CVE_patch_result(CVEID=CVEID)
    print(True if 'https://github.com/apache/karaf-site/commit/1ebfa39eceb6ad7eddd8ac430cdb7db87bda8353' not in [
        ele.formatted_url for ele in res] else False)
    # 过滤 doc/test commit

def unify_patch_format_for_evalution_text():
    tc = 'git_5192488834309d2f05528fad'
    print(unify_patch_format_for_evalution([tc]))

if __name__ == '__main__':
    # main_evaluate_vulnerabilityDB_huizong()
    main_evaluate_vulnerabilityDB()
    # main_evaluate_ours()
    # generate_localized_CVE_patch_result_of_CVEIDs()

    # test
    # run_single()
    # unify_patch_format_for_evalution_test()
    # generate_localized_CVE_patch_result_test()
    # unify_patch_format_for_evalution_text()
    # check_GT()
    # load_ground_truth()
    # json_processing.write( json_content=GT_classification_info, path='GT_classification_info.json')
    # json_processing.write(json_content=formal_GT, path='formal_GT.json')
    # print( GT_classification_info )
    # original_formal_GT, original_GT_classification_info = load_ground_truth()
    # new_formal_GT, new_GT_classification_info = load_ground_truth_with_new_classification()
    # print( original_formal_GT, original_GT_classification_info  )